<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>bWAPP靶场</title>
    <link href="/2020/08/25/bWAPP%E9%9D%B6%E5%9C%BA/"/>
    <url>/2020/08/25/bWAPP%E9%9D%B6%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>靶场</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内网信息收集</title>
    <link href="/2020/08/18/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <url>/2020/08/18/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="收集本机信息"><a href="#收集本机信息" class="headerlink" title="收集本机信息"></a>收集本机信息</h2><h3 id="nbsp-nbsp-手动收集"><a href="#nbsp-nbsp-手动收集" class="headerlink" title="&nbsp;&nbsp;手动收集"></a>&nbsp;&nbsp;手动收集</h3><h4 id="nbsp-nbsp-nbsp-nbsp-查询操作系统和版本信息"><a href="#nbsp-nbsp-nbsp-nbsp-查询操作系统和版本信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询操作系统和版本信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询操作系统和版本信息</h4><pre><code>systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</code></pre><p><img src="https://i.loli.net/2020/08/26/VTpqd8njIeClOZc.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;在中文系统中时候后面的命令才有显示</p><h4 id="nbsp-nbsp-nbsp-nbsp-查看系统体系结构"><a href="#nbsp-nbsp-nbsp-nbsp-查看系统体系结构" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看系统体系结构"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看系统体系结构</h4><pre><code>echo %PROCESSOR_ARCHITECTURE%</code></pre><p><img src="https://i.loli.net/2020/08/26/LMDsCWP5zKcUk4b.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查看安装的软件及版本、路径等"><a href="#nbsp-nbsp-nbsp-nbsp-查看安装的软件及版本、路径等" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看安装的软件及版本、路径等"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看安装的软件及版本、路径等</h4><pre><code>wmic product get name,version</code></pre><p><img src="https://i.loli.net/2020/08/26/xDgosX9hrtf3zkY.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-使用powershell命令，搜集软件的版本信息"><a href="#nbsp-nbsp-nbsp-nbsp-使用powershell命令，搜集软件的版本信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;使用powershell命令，搜集软件的版本信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;使用powershell命令，搜集软件的版本信息</h4><pre><code>powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</code></pre><p><img src="https://i.loli.net/2020/08/26/phWzbNcPkOCBsJ3.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询本机服务信息"><a href="#nbsp-nbsp-nbsp-nbsp-查询本机服务信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询本机服务信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询本机服务信息</h4><pre><code>wmic service list brief</code></pre><p><img src="https://i.loli.net/2020/08/26/1hnilNuesK4DpOv.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询进程列表"><a href="#nbsp-nbsp-nbsp-nbsp-查询进程列表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询进程列表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询进程列表</h4><pre><code>tasklist</code></pre><p>&nbsp;&nbsp;查看当前进程列表和进程用户、分析软件、邮件客户端、vpn和杀毒软件等进程</p><pre><code>wmic process list brief</code></pre><p><img src="https://i.loli.net/2020/08/26/61nK2UEVB9bANRF.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查看启动程序信息"><a href="#nbsp-nbsp-nbsp-nbsp-查看启动程序信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看启动程序信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看启动程序信息</h4><pre><code>wmic startup get command,caption</code></pre><p><img src="https://i.loli.net/2020/08/26/eocD6f8swNOU5b1.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查看计划任务"><a href="#nbsp-nbsp-nbsp-nbsp-查看计划任务" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看计划任务"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看计划任务</h4><pre><code>chcp 437   将文字转化为英文显示schtasks /query /fo LIST /v</code></pre><p><img src="https://i.loli.net/2020/08/26/z6mDnZSYbouh4MT.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;若直接使用schasks命令则会出现提示列资源无法加载</p><h4 id="nbsp-nbsp-nbsp-nbsp-查看主机开机时间"><a href="#nbsp-nbsp-nbsp-nbsp-查看主机开机时间" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看主机开机时间"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看主机开机时间</h4><pre><code>net statistics workstation</code></pre><p><img src="https://i.loli.net/2020/08/26/LWj3nag1cG4TS6H.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询用户列表"><a href="#nbsp-nbsp-nbsp-nbsp-查询用户列表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询用户列表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询用户列表</h4><pre><code>net user</code></pre><p><img src="https://i.loli.net/2020/08/26/rhC5WvpJVEkNa4l.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;通过分析本机用户列表，可以找出内网机器的命名规则，用来推测整个域的用户命名方式。</p><p>&nbsp;&nbsp;获取本地管理员信息</p><pre><code>net localgroup administrators</code></pre><p><img src="https://i.loli.net/2020/08/26/MR8DbGXHLEtOuys.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;查看当前在线用户</p><pre><code>query user || qwinsta</code></pre><p><img src="https://i.loli.net/2020/08/26/1TfbJtosx6U5GXr.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-列出或断开本地计算机与所连接的客户端之间的会话"><a href="#nbsp-nbsp-nbsp-nbsp-列出或断开本地计算机与所连接的客户端之间的会话" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;列出或断开本地计算机与所连接的客户端之间的会话"></a>&nbsp;&nbsp;&nbsp;&nbsp;列出或断开本地计算机与所连接的客户端之间的会话</h4><pre><code>net session</code></pre><p><img src="https://i.loli.net/2020/08/26/ZmVJ3KM9FHdNUAX.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询端口列表"><a href="#nbsp-nbsp-nbsp-nbsp-查询端口列表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询端口列表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询端口列表</h4><pre><code>netstat -ano</code></pre><p><img src="https://i.loli.net/2020/08/26/zsA3dVIHulQ2Z1y.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;此时可以看到当前机器和哪些主机建立了连接，以及TCP、UDP等端口的使用和监听情况。</p><h4 id="nbsp-nbsp-nbsp-nbsp-查询补丁信息"><a href="#nbsp-nbsp-nbsp-nbsp-查询补丁信息" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询补丁信息"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询补丁信息</h4><pre><code>systeminfo</code></pre><p><img src="https://i.loli.net/2020/08/26/4C6fqSpA1hm7Dcw.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;需要注意系统的版本、补丁信息和更新频率</p><pre><code>wmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><p><img src="https://i.loli.net/2020/08/26/gxkprnvOQYfXwZH.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;补丁的名称、描述、ID等</p><h4 id="nbsp-nbsp-nbsp-nbsp-查询本机共享列表"><a href="#nbsp-nbsp-nbsp-nbsp-查询本机共享列表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询本机共享列表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询本机共享列表</h4><pre><code>net share</code></pre><p><img src="https://i.loli.net/2020/08/26/zFEX7ToHqhO8vge.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;查看本机共享列表和可访问的域共享列表</p><pre><code>wmic share get name,path,status</code></pre><p><img src="https://i.loli.net/2020/08/26/oumsYMgqSDCVftz.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询路由表及所有可用接口的ARP缓冲表"><a href="#nbsp-nbsp-nbsp-nbsp-查询路由表及所有可用接口的ARP缓冲表" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询路由表及所有可用接口的ARP缓冲表"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询路由表及所有可用接口的ARP缓冲表</h4><pre><code>route printarp -a</code></pre><p><img src="https://i.loli.net/2020/08/26/StEeGpB5PxHnuOJ.png" srcset="/img/loading.gif" alt=""></p><h4 id="nbsp-nbsp-nbsp-nbsp-查询防火墙相关配置"><a href="#nbsp-nbsp-nbsp-nbsp-查询防火墙相关配置" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询防火墙相关配置"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询防火墙相关配置</h4><p>&nbsp;&nbsp;（1）关闭防火墙</p><pre><code>win 2003及之前的版本用这条命令：netsh firewall set opmode disablewin 2003之后的版本用这条命令：netsh advfirewall set allprofiles state off</code></pre><p>&nbsp;&nbsp;（2）查看防火墙配置</p><pre><code>netsh firewall show config</code></pre><p><img src="https://i.loli.net/2020/08/26/tClHTzeQuJOvYNA.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;（3）修改防火墙配置</p><pre><code>win 2003及之前的版本，运行指定程序全部连接：netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enablewin 2003之后的版本用这条：netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;允许指定程序连出，命令如下netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;允许 3389 端口放行，命令如下netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow自定义防火墙日志储存位置netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-查看代理配置情况"><a href="#nbsp-nbsp-nbsp-nbsp-查看代理配置情况" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查看代理配置情况"></a>&nbsp;&nbsp;&nbsp;&nbsp;查看代理配置情况</h4><pre><code>reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</code></pre><p><img src="https://i.loli.net/2020/08/26/JMcWiNFzK3pHsP1.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;可以看到服务器1080端口配置信息</p><h4 id="nbsp-nbsp-nbsp-nbsp-查询并开启远程连接服务"><a href="#nbsp-nbsp-nbsp-nbsp-查询并开启远程连接服务" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;查询并开启远程连接服务"></a>&nbsp;&nbsp;&nbsp;&nbsp;查询并开启远程连接服务</h4><p>&nbsp;&nbsp;（1）查看远程连接端口</p><pre><code>REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber</code></pre><p><img src="https://i.loli.net/2020/08/26/L7nrAVemwbCM2Fp.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;在cmd下使用注册表查询语句，得到连接端口为0xd3d，转换后为3389</p><p>&nbsp;&nbsp;（2）在 Windows Server 2003 中开启 3389 端口</p><pre><code>wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;)  call setallowtsconnections 1</code></pre><p>&nbsp;&nbsp;（3）在Windows Server 2008和Windows Server 2012中开启3389端口</p><pre><code>wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&apos;RDP-Tcp&apos;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</code></pre><h3 id="nbsp-nbsp-自动收集信息"><a href="#nbsp-nbsp-自动收集信息" class="headerlink" title="&nbsp;&nbsp;自动收集信息"></a>&nbsp;&nbsp;自动收集信息</h3><p>&nbsp;&nbsp;使用WMIC自动脚本来收集信息,打开运行wmic_info.bat会自动生成一个 out.html文件</p><p><img src="https://i.loli.net/2020/08/26/VXC2J43ATSxNuit.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;同样也可以使用工具 <strong>Empire</strong> </p><pre><code>git clone https://github.com/EmpireProject/Empire.git</code></pre><h2 id="查询当前权限"><a href="#查询当前权限" class="headerlink" title="查询当前权限"></a>查询当前权限</h2><h3 id="nbsp-nbsp-查看当前权限"><a href="#nbsp-nbsp-查看当前权限" class="headerlink" title="&nbsp;&nbsp;查看当前权限"></a>&nbsp;&nbsp;查看当前权限</h3><p>&nbsp;&nbsp;查看当前权限</p><pre><code>whoami</code></pre><p>&nbsp;&nbsp;获取当前主机权限后，有三种情况：①本地普通用户，②本地管理员用户，③域内用户</p><p><img src="https://i.loli.net/2020/08/26/ecAXm3BzrDR2WKj.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;在以上三种情况下，如果当前内网中存在域，那么本地普通用户只能查询本机相关信息，不能查询域内信息；而本地管理员用户和域内用户可以查询域内信息。其原理是：域内的所有查询都是通过域控制器实现的（基于LDAP协议），而这个查询需要经过权限认证，所以只有域用户才拥有这个权限；当域用户执行查询命令时，会自动使用kerberos协议进行认证，无须额外输入账号密码。</p><h3 id="nbsp-nbsp-获取域ID"><a href="#nbsp-nbsp-获取域ID" class="headerlink" title="&nbsp;&nbsp;获取域ID"></a>&nbsp;&nbsp;获取域ID</h3><pre><code>whoami /all</code></pre><p><img src="https://i.loli.net/2020/08/26/msOIot56kap7bYW.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2020/08/26/bZSQcwMpu71ziEO.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-查询指定用户的详细信息"><a href="#nbsp-nbsp-查询指定用户的详细信息" class="headerlink" title="&nbsp;&nbsp;查询指定用户的详细信息"></a>&nbsp;&nbsp;查询指定用户的详细信息</h3><pre><code>net user xxx /domain</code></pre><p><img src="https://i.loli.net/2020/08/26/YrgDnVzLUs7XJNW.png" srcset="/img/loading.gif" alt=""></p><h2 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h2><h3 id="nbsp-nbsp-ipconfig命令"><a href="#nbsp-nbsp-ipconfig命令" class="headerlink" title="&nbsp;&nbsp;ipconfig命令"></a>&nbsp;&nbsp;ipconfig命令</h3><pre><code>ipconfig /all</code></pre><p><img src="https://i.loli.net/2020/08/26/nKXepwF9z4JaUbV.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后通过反向解析查询命令nslookup来解析域名的IP地址。再用解析的IP地址与IP地址比较来判断域控制器和DNS服务器是否在同一台服务器上。</p><pre><code>nslookup hack.testlab</code></pre><p><img src="https://i.loli.net/2020/08/26/MKIPDaw5Ezdbxuc.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-查看系统详细信息"><a href="#nbsp-nbsp-查看系统详细信息" class="headerlink" title="&nbsp;&nbsp;查看系统详细信息"></a>&nbsp;&nbsp;查看系统详细信息</h3><pre><code>systeminfo</code></pre><p><img src="https://i.loli.net/2020/08/26/m6EqiIuM8VYRKA9.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;域显示就是域名，登录服务器就是域控制器。若域为WORKGROUP表示不在服务器。</p><h3 id="nbsp-nbsp-查询当前登录域及登录用户信息"><a href="#nbsp-nbsp-查询当前登录域及登录用户信息" class="headerlink" title="&nbsp;&nbsp;查询当前登录域及登录用户信息"></a>&nbsp;&nbsp;查询当前登录域及登录用户信息</h3><pre><code>net config workstation</code></pre><p><img src="https://i.loli.net/2020/08/26/5yBr7G6QliqUSOe.png" srcset="/img/loading.gif" alt=""></p><h3 id="nbsp-nbsp-判断主域"><a href="#nbsp-nbsp-判断主域" class="headerlink" title="&nbsp;&nbsp;判断主域"></a>&nbsp;&nbsp;判断主域</h3><p>&nbsp;&nbsp;域服务器通常会同时作为时间服务器使用</p><p>&nbsp;&nbsp;有三种情况，第一种中存在域，当前是域用户：</p><p><img src="https://i.loli.net/2020/08/26/l3mOiwH6IjxRT7g.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;第二种是，不存在域，环境是工作组：</p><p><img src="https://i.loli.net/2020/08/26/lfQmMCK438ZzFPb.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;第三种是，存在域，但是当前用户不是域用户</p><p><img src="https://i.loli.net/2020/08/26/znqxPvcFw1jprXo.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>内网攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网渗透基础</title>
    <link href="/2020/08/09/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/08/09/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>本篇文章对内网基础的知识进行总结，以及布置实验使用的内网环境和工具。学习的资料来自 电子工业出版社的 <strong>内网安全攻防</strong> (作者徐焱、贾晓璐)，仅供个人学习研究使用</p><h2 id="内网基础概念"><a href="#内网基础概念" class="headerlink" title="内网基础概念"></a>内网基础概念</h2><p>&nbsp;&nbsp;<strong>内网</strong>也指<strong>局域网(LAN)</strong>，是指<strong>某一区域由多台计算机互连而成的计算机工作组</strong>。</p><h3 id="nbsp-nbsp-nbsp-nbsp-工作组"><a href="#nbsp-nbsp-nbsp-nbsp-工作组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;工作组"></a>&nbsp;&nbsp;&nbsp;&nbsp;工作组</h3><p>&nbsp;&nbsp;<strong>工作组(group)</strong>是指将计算机<strong>按照不同功能或部门列入不同小组</strong>。工作组没有集中管理作用，等级是<strong>对等</strong>的。</p><h3 id="nbsp-nbsp-nbsp-nbsp-域"><a href="#nbsp-nbsp-nbsp-nbsp-域" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域"></a>&nbsp;&nbsp;&nbsp;&nbsp;域</h3><p>&nbsp;&nbsp;<strong>域(domain)</strong>是一个有安全边界的计算机集合，用户在域内的拥有什么资源是取决于用户的身份。</p><p>&nbsp;&nbsp;<strong>域控制器(domian controller,DC)</strong> 是域中一台类似<strong>管理服务器</strong>的计算机，DC内<strong>存储着属于这个域的账户、密码、计算机等信息构成的数据库</strong>。所有权限身份的操作都在域控制器上进行</p><p>&nbsp;&nbsp;域一般有以下环境：<strong>单域；父域和子域；域树；域森林；域名服务器</strong>。</p><h4 id="nbsp-nbsp-nbsp-nbsp-单域"><a href="#nbsp-nbsp-nbsp-nbsp-单域" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;单域"></a>&nbsp;&nbsp;&nbsp;&nbsp;单域</h4><p>&nbsp;&nbsp;一般在<strong>规模较小、地理位置固定</strong>的小公司内，一个域即可满足需求，单域内一般有两台DC，一台运行，另一台作为备份。</p><h4 id="nbsp-nbsp-nbsp-nbsp-父域和子域"><a href="#nbsp-nbsp-nbsp-nbsp-父域和子域" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;父域和子域"></a>&nbsp;&nbsp;&nbsp;&nbsp;父域和子域</h4><p>&nbsp;&nbsp;出于需求，将一个域划分成多个域，<strong>第一个域成为父域</strong>而<strong>各分部的域称为子域</strong>。划分多个域的好处是分部可以通过自己的域来<strong>管理自己的资源和分配自己的安全策略</strong>。</p><blockquote><p>在一个大的域内信息交互条目多，同步时间也多且不会压缩；而在域之间交互条目小，还可压缩</p></blockquote><h4 id="nbsp-nbsp-nbsp-nbsp-域树"><a href="#nbsp-nbsp-nbsp-nbsp-域树" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域树"></a>&nbsp;&nbsp;&nbsp;&nbsp;域树</h4><p>&nbsp;&nbsp;<strong>域树(Tree)</strong>是<strong>多个域通过建立信任关系组成的集合</strong>。不同的域之间若要互相访问，则需要建立<strong>信任关系(Trust Relation)</strong>。</p><p>&nbsp;&nbsp;在一个域树中，各个子域使用 <strong>.</strong> 号分隔开的，一个点号代表一个层次。放在域名最后的子域称为最高级子域或一级子域，且子域只能使用父域的名字作为其域名后缀</p><h4 id="nbsp-nbsp-nbsp-nbsp-域森林"><a href="#nbsp-nbsp-nbsp-nbsp-域森林" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域森林"></a>&nbsp;&nbsp;&nbsp;&nbsp;域森林</h4><p>&nbsp;&nbsp;<strong>域森林(Forest)</strong>是指<strong>多个域树通过建立信任关系组成的集合</strong>。可以通过域树之间的信任关系，可以管理和使用整个域森林中的资源。</p><h4 id="nbsp-nbsp-nbsp-nbsp-域名服务器"><a href="#nbsp-nbsp-nbsp-nbsp-域名服务器" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域名服务器"></a>&nbsp;&nbsp;&nbsp;&nbsp;域名服务器</h4><p>&nbsp;&nbsp;DNS是用于<strong>实现域名和与之相对应的IP地址转换</strong>的服务器。</p><h3 id="nbsp-nbsp-活动目录"><a href="#nbsp-nbsp-活动目录" class="headerlink" title="&nbsp;&nbsp;活动目录"></a>&nbsp;&nbsp;活动目录</h3><p>&nbsp;&nbsp;<strong>活动目录(Active Directory,AD)</strong>是指域环境中<strong>提供目录服务</strong>的组件。</p><p>&nbsp;&nbsp;目录服务是指帮助用户快速、准确从目录中找到目录中需要的信息的服务。</p><p>&nbsp;&nbsp;在活动目录中，管理员不需要考虑管理对象的地理位置。这种不考虑管理对象地理位置的组织框架成为<strong>逻辑结构</strong></p><p>&nbsp;&nbsp;活动目录主要提供的功能：<strong>账号集中管理、软件集中管理，环境集中管理、增强安全性和更可靠，更少的宕机时间</strong>。</p><h3 id="nbsp-nbsp-域控制器与活动目录区别"><a href="#nbsp-nbsp-域控制器与活动目录区别" class="headerlink" title="&nbsp;&nbsp;域控制器与活动目录区别"></a>&nbsp;&nbsp;域控制器与活动目录区别</h3><p>&nbsp;&nbsp;如果网络规模较大，就会考虑把网络中的众多对象分门别类并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。</p><p>&nbsp;&nbsp;实现域环境，其实就是要安装AD，安装AD的计算机就是变成DC。</p><h3 id="nbsp-nbsp-安全域划分"><a href="#nbsp-nbsp-安全域划分" class="headerlink" title="&nbsp;&nbsp;安全域划分"></a>&nbsp;&nbsp;安全域划分</h3><p>&nbsp;&nbsp;划分安全域目的就是将<strong>一组安全等级相同的计算机划入同网段</strong>。当攻击发生时，能够降低对域内计算机的影响。</p><p>&nbsp;&nbsp;内网一般分为三个区域：安全级别最高的内网，安全级别中等的DMZ，安全级别最低的外网。</p><p>&nbsp;&nbsp;<strong>DMZ</strong> 称为隔离区，也称非军事化区。是为了<strong>解决安装防火墙后外部网络不能访问内部网络服务器的问题</strong>，而设立的一个非安全系统与安全系统之间的<strong>缓冲区</strong>。</p><p>&nbsp;&nbsp;配置一个拥有DMZ的网络时需要定义访问控制策略：<strong>内网可以访问外网、内网可以访问DMZ、外网不能访问内网、DMZ不能访问内网、DMZ不能访问外网</strong>。</p><h3 id="nbsp-nbsp-域中计算机分类"><a href="#nbsp-nbsp-域中计算机分类" class="headerlink" title="&nbsp;&nbsp;域中计算机分类"></a>&nbsp;&nbsp;域中计算机分类</h3><p>&nbsp;&nbsp;<strong>域控制器</strong>：用于管理所有的网络访问，包括登录服务器、访问共享目录和资源</p><p>&nbsp;&nbsp;<strong>成员服务器</strong>：安装了服务器操作系统并加入域、但没有安装活动目录的计算机</p><p>&nbsp;&nbsp;<strong>客户机</strong></p><p>&nbsp;&nbsp;<strong>独立服务器</strong>：独立服务器和域无关。如果服务器不加入域，也不安装活动目录，就是独立服务器。</p><p>&nbsp;&nbsp;域控制器用于存放活动目录数据库，是域中必须要有的。</p><p>&nbsp;&nbsp;域中各个服务器的角色也是可以<strong>改变</strong>的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。</p><h3 id="nbsp-nbsp-域内权限"><a href="#nbsp-nbsp-域内权限" class="headerlink" title="&nbsp;&nbsp;域内权限"></a>&nbsp;&nbsp;域内权限</h3><p>&nbsp;&nbsp;<strong>组（Group）</strong>是用户帐号的集合。通过向一组用户分配权限从而不必向每个用户分配权限。</p><p>&nbsp;&nbsp;域本地组：来自全林用于本域</p><p>&nbsp;&nbsp;全局组：来自本域用于全林</p><p>&nbsp;&nbsp;通用组：来自全林用于全林</p><h4 id="nbsp-nbsp-nbsp-nbsp-域本地组"><a href="#nbsp-nbsp-nbsp-nbsp-域本地组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;域本地组"></a>&nbsp;&nbsp;&nbsp;&nbsp;域本地组</h4><p>&nbsp;&nbsp;可以从任何域添加用户账户、通用组和全局组。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。</p><h4 id="nbsp-nbsp-nbsp-nbsp-全局组"><a href="#nbsp-nbsp-nbsp-nbsp-全局组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;全局组"></a>&nbsp;&nbsp;&nbsp;&nbsp;全局组</h4><p>&nbsp;&nbsp;只能在创建该全局组的域上进行添加用户账户和全局组，但全局组可以嵌套在其他组中。</p><h4 id="nbsp-nbsp-nbsp-nbsp-通用组"><a href="#nbsp-nbsp-nbsp-nbsp-通用组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;通用组"></a>&nbsp;&nbsp;&nbsp;&nbsp;通用组</h4><p>&nbsp;&nbsp;通用组是集合了上面两种组的优点，即可以从任何域中添加用户和组，可以嵌套于其他域组中。</p><h4 id="nbsp-nbsp-nbsp-nbsp-A-G-DL-P策略"><a href="#nbsp-nbsp-nbsp-nbsp-A-G-DL-P策略" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;A-G-DL-P策略"></a>&nbsp;&nbsp;&nbsp;&nbsp;A-G-DL-P策略</h4><p>&nbsp;&nbsp;<strong>A(account)</strong>                    表示用户账号</p><p>&nbsp;&nbsp;<strong>G(Global group)</strong>                表示全局组</p><p>&nbsp;&nbsp;<strong>U(Universal group)</strong>            表示通用组</p><p>&nbsp;&nbsp;<strong>DL(Domain local group)</strong>        表示域本地组</p><p>&nbsp;&nbsp;<strong>P(Permission 许可)</strong>            表示资源权限。</p><p>&nbsp;&nbsp;A-G-DL-P策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。按照AGDLP的原则对用户进行组织和管理起来更容易。</p><p>&nbsp;&nbsp;在AGDLP形成以后,当给一个用户某一个权限的时候,只要把这个用户加入到某一个本地域组就可以了。</p><p>&nbsp;&nbsp;几个比较重要的域本地组权限</p><pre><code>Administrators（管理员组)            权限最高，域森林中最强大Remote Desktop Users(远程登录组)        有远程登陆权限Print Operators（打印机操作员组）        管理网络打印机，本地登录和关闭DCAccount Operators（帐号操作员组）        Server Operaters（服务器操作员组)        管理域服务器Backup Operators（备份操作员组）        在域控制器中执行备份和还原</code></pre><p>&nbsp;&nbsp;几个全局组、通用组的权限</p><pre><code>Domain Admins（域管理员组）                Enterprise Admins（企业系统管理员组）Schema Admins（架构管理员组）Domain Users（域用户组）</code></pre><p>&nbsp;</p><h2 id="PowerShell基础"><a href="#PowerShell基础" class="headerlink" title="PowerShell基础"></a>PowerShell基础</h2><p>&nbsp;&nbsp;PowerShell是一种命令行外壳程序和脚本环境，内置于每个受支持的Windows版本中，可以看作cmd的拓展。</p><p>&nbsp;&nbsp;winser12可直接打开</p><p><img src="https://i.loli.net/2020/08/26/i7tcxwW59TE4DXC.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;输入 <strong>Get-Host</strong> 或 <strong>$PSversionTable.PSVersion</strong> 可以查看版本</p><h3 id="nbsp-nbsp-PowerShell基本概念"><a href="#nbsp-nbsp-PowerShell基本概念" class="headerlink" title="&nbsp;&nbsp;PowerShell基本概念"></a>&nbsp;&nbsp;PowerShell基本概念</h3><h4 id="nbsp-amp-nbsp-nbsp-nbsp-ps1文件"><a href="#nbsp-amp-nbsp-nbsp-nbsp-ps1文件" class="headerlink" title="&nbsp;&amp;nbsp&nbsp;&nbsp;;.ps1文件"></a>&nbsp;&amp;nbsp&nbsp;&nbsp;;.ps1文件</h4><p>&nbsp;&nbsp;PowerShell就是简单的文本文件，拓展名为 <strong>.ps1</strong> </p><h4 id="nbsp-nbsp-nbsp-nbsp-执行策略"><a href="#nbsp-nbsp-nbsp-nbsp-执行策略" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;执行策略"></a>&nbsp;&nbsp;&nbsp;&nbsp;执行策略</h4><p>&nbsp;&nbsp;为防止使用者恶意运行脚本，PowerShell提供的默认策略是：不能运行</p><p>&nbsp;&nbsp;如果脚本不能运行，可以使用 <strong>Get-ExecutionPolicy</strong> 来查询当前的执行策略</p><p><img src="https://i.loli.net/2020/08/26/te5RBzcpTKxIAQy.png" srcset="/img/loading.gif" alt=""></p><pre><code>Restricted：脚本不能运行RemoteSigned：在本地创建的脚本可以运行，网上下载的不可（有数字证书也可）ALLSigned：仅当脚本由受信任的发布者签名时才能运行Unrestricted：允许所有脚本运行</code></pre><p>&nbsp;<br>&nbsp;&nbsp;也可以使用cmdlet命令来设置PowerShell的执行策略</p><pre><code>Set-ExecutionPolicy &lt;policy name&gt;</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-运行脚本"><a href="#nbsp-nbsp-nbsp-nbsp-运行脚本" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;运行脚本"></a>&nbsp;&nbsp;&nbsp;&nbsp;运行脚本</h4><p>&nbsp;&nbsp;要运行一个脚本，必需输入完整路径和文件名或者在当前目录输入（和Linux命令类似）例如： .\a.spl</p><h4 id="nbsp-nbsp-nbsp-nbsp-管道"><a href="#nbsp-nbsp-nbsp-nbsp-管道" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;管道"></a>&nbsp;&nbsp;&nbsp;&nbsp;管道</h4><p>&nbsp;&nbsp;管道的作用是将一个命令的输出作为另一个命令的输入，两个命令之间用 <strong>|</strong> 连接。</p><h3 id="nbsp-nbsp-常用命令"><a href="#nbsp-nbsp-常用命令" class="headerlink" title="&nbsp;&nbsp;常用命令"></a>&nbsp;&nbsp;常用命令</h3><h4 id="nbsp-nbsp-nbsp-nbsp-基本支持"><a href="#nbsp-nbsp-nbsp-nbsp-基本支持" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;基本支持"></a>&nbsp;&nbsp;&nbsp;&nbsp;基本支持</h4><p>&nbsp;&nbsp;PowerShell下类似cmd命令的称为cmdlet命令，命名规范一致，都采用“动词-名词”，命令不区分大小写。</p><pre><code>1、新建目录：New-ltem whitecellclub-ltemType Directory。2、新建文件：New-ltem light.txt-ltemType File。3、删除目录：Remove-ltem whitecellclub。4、显示文本内容：Get-Content test.txt。5、设置文本内容：Set-Content test.txt-Va l u e&apos;&apos;hello,word! &apos;&apos;。6、追加内容：Add-Content light.txt-Value &apos;&apos;i love you &apos;&apos;。7、清除内容：Clear-Content test.txt。</code></pre><p>&nbsp;</p><h2 id="VMware域环境配置"><a href="#VMware域环境配置" class="headerlink" title="VMware域环境配置"></a>VMware域环境配置</h2><h3 id="nbsp-nbsp-基本配置"><a href="#nbsp-nbsp-基本配置" class="headerlink" title="&nbsp;&nbsp;基本配置"></a>&nbsp;&nbsp;基本配置</h3><p>&nbsp;&nbsp;首先对虚拟机进行配置自定义网络</p><p><img src="https://i.loli.net/2020/08/26/cCwFXyEeY1brlON.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;这里新建了一个VMnet2作为域专用地址，可以通过设置子网IP和DHCP分配的地址来进行对虚拟机进行分配，不过不能设置网关，需要虚拟机单独去配置（基本DHCP就没什么用了）</p><p>&nbsp;&nbsp;这里使用了三台测试机，分别为WinSer2012作为网关和DNS的地址，WinSer08和一台win7作为域内其他主机。</p><p>&nbsp;&nbsp;对每台设备进行关闭防火墙和IP地址配置，让三台主机都互相能够ping通</p><p><img src="https://i.loli.net/2020/08/26/xLYEeNC5KShHcPO.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后对WinSer2012进行改名，改为DC</p><p><img src="https://i.loli.net/2020/08/26/9yMndFmbaLixCVE.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;重启Winser2012后，对该服务器进行配置。进行添加DNS和AD域服务。</p><p><img src="https://i.loli.net/2020/08/26/1owfePdLJ7nsZxN.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后默认点击下一步然后安装。</p><p>&nbsp;&nbsp;点击出现的黄色感叹。</p><p><img src="https://i.loli.net/2020/08/26/BaeUuYgm8pxMFih.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;按照要求配置根域名</p><p><img src="https://i.loli.net/2020/08/26/uhTwoSIlRPn9mqY.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2020/08/26/kLlzoutVvWRNxMq.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后一直默认下一步，直到安装完成，重启</p><p><img src="https://i.loli.net/2020/08/26/tr7l46c5QeN3RpA.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;接下来对AD添加用户</p><p><img src="https://i.loli.net/2020/08/26/d5qZz9DxU37uskP.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;选择用户和计算机</p><p><img src="https://i.loli.net/2020/08/26/8uRsXdKrZkh1DYB.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后创建用户名和密码</p><h3 id="nbsp-nbsp-加入域"><a href="#nbsp-nbsp-加入域" class="headerlink" title="&nbsp;&nbsp;加入域"></a>&nbsp;&nbsp;加入域</h3><p>&nbsp;&nbsp;接下来到win7上加入域</p><p><img src="https://i.loli.net/2020/08/26/Yr7nQFTGAL14NaZ.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后输入刚刚创建的用户密码</p><p><img src="https://i.loli.net/2020/08/26/eB7ZydLADitqxWY.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;显示成功加入域</p><p><img src="https://i.loli.net/2020/08/26/Y2PxmLHIf8epdvX.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;然后重启成功加入域，同时ping域名</p><p><img src="https://i.loli.net/2020/08/26/ymrURbohw3PZAV2.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;&nbsp;到此，完成了创建域和加入域的操作</p>]]></content>
    
    
    <categories>
      
      <category>内网攻防</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP语言基础</title>
    <link href="/2020/07/30/PHP%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/30/PHP%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>这篇文章简单对PHP的各种常用基础知识进行介绍，以理解为重点，省略大部分运行情况</p><h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><h3 id="nbsp-nbsp-数据结构"><a href="#nbsp-nbsp-数据结构" class="headerlink" title="&nbsp;&nbsp;数据结构"></a>&nbsp;&nbsp;数据结构</h3><h4 id="nbsp-nbsp-nbsp-nbsp-数据类型"><a href="#nbsp-nbsp-nbsp-nbsp-数据类型" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;数据类型"></a>&nbsp;&nbsp;&nbsp;&nbsp;数据类型</h4><p>&nbsp; 1.1 <strong>boolean</strong></p><p>&nbsp; &nbsp; <code>$boo = true</code>    将变量命名为布尔型<br>&nbsp; 1.2 <strong>string</strong></p><p>&nbsp; &nbsp; <code>$a = &#39;字符串&#39;</code> 单引号的变量按普通字符串输出</p><p>&nbsp; &nbsp; <code>$a = &quot;字符串&quot;</code>    双引号中包含的变量会被自动替换成实际数值</p><p>&nbsp; &nbsp; <code>$string = &lt;&lt;&lt;str    要输出的字符    str</code>    输出字符，效果同双引号</p><p>&nbsp; 1.3 <strong>integer</strong></p><p>&nbsp; &nbsp; 可以声明十进制、八进制和十六进制整数</p><p>&nbsp; 1.4 <strong>float</strong></p><p>&nbsp; &nbsp; 提供两种书写格式：标准格式和科学计数法（例 3.58E1,87E-3）</p><p>&nbsp; 1.5 <strong>array</strong></p><p>&nbsp; &nbsp; 一组数据的集合</p><p>&nbsp; &nbsp; 语法格式：<code>$array = array(&#39;value1&#39;,&#39;value2&#39;)</code> 或 <code>$array[key]=&#39;value&#39;</code> 或 <code>$array = array(key1 =&gt; value1,key2=&gt;value2)</code></p><p>&nbsp; &nbsp; 其中 <strong>key</strong> 是数组元素的下标， <strong>value</strong> 是数组下标对应的元素</p><p>&nbsp; 1.6 <strong>object</strong></p><p>&nbsp; &nbsp; 面向对象和面向过程</p><p>&nbsp; 1.7 <strong>特殊数据类型</strong></p><p>&nbsp; 资源（resource）和空值（null）</p><pre><code>&gt;资源：又叫句柄，保存了到外部资源的一个引用&gt;空值：表示变量没有值&gt;unset()：销毁指定的变量</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-数据类型转换"><a href="#nbsp-nbsp-nbsp-nbsp-数据类型转换" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;数据类型转换"></a>&nbsp;&nbsp;&nbsp;&nbsp;数据类型转换</h4><p>&nbsp; &nbsp; 变量前加上 <strong>小括号</strong> 括起来的类型即可</p><pre><code>(boolean)$sum 、(inter)$boo</code></pre><p>&nbsp; &nbsp; 函数 <strong>settype（）</strong> 完成</p><pre><code>bool settype(mixed var,string type)</code></pre><p>&nbsp; &nbsp; <strong>var</strong>  —— 指定的变量</p><p>&nbsp; &nbsp; <strong>type</strong> —— 指定的类型（boolean、float、integer、array、null、object、string）</p><p>&nbsp; &nbsp; 转换成功返回 true 失败则 false</p><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-检测数据类型"><a href="#nbsp-nbsp-nbsp-nbsp-检测数据类型" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;检测数据类型"></a>&nbsp;&nbsp;&nbsp;&nbsp;检测数据类型</h4><p>&nbsp; &nbsp; PHP内有许多内置函数关于检测，为 <strong>is</strong> 系列</p><pre><code>is_bool ; is_string ; is_float ; is_int ; is_null ; is_array ; is_null ; is_object ; is_numeric(检测是否为数字或者由数字组成的字符串)</code></pre><p>&nbsp; </p><h3 id="nbsp-nbsp-常量"><a href="#nbsp-nbsp-常量" class="headerlink" title="&nbsp;&nbsp;常量"></a>&nbsp;&nbsp;常量</h3><h4 id="nbsp-nbsp-nbsp-nbsp-声明和使用"><a href="#nbsp-nbsp-nbsp-nbsp-声明和使用" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;声明和使用"></a>&nbsp;&nbsp;&nbsp;&nbsp;声明和使用</h4><p>&nbsp;&nbsp;使用 <strong>define()</strong> 来定常量</p><pre><code>define(string constant_name,mixed value,case_sensitive=false)constant_name : 必选参数，常量名称，即标识符value : 必选参数，常量的值case_sensitive : 可选参数，指定是否大小写敏感，true则不敏感</code></pre><p>&nbsp;&nbsp;获取常量设置的值有两种方法，一种是使用常量名输出，另一种是使用函数 <strong>constant()</strong> 输出</p><pre><code>mixed constant(string const_name)const_name : 常量名，成功则返回常量的值，失败则输出错误</code></pre><p>&nbsp;&nbsp;判断常量是否被定义可以使用 <strong>defined()</strong> 函数</p><pre><code>bool defined(string constant_name)constant_name : 常量名称，存在则返回true，否则是false</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-预定义常量"><a href="#nbsp-nbsp-nbsp-nbsp-预定义常量" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;预定义常量"></a>&nbsp;&nbsp;&nbsp;&nbsp;预定义常量</h4><p>&nbsp;&nbsp;PHP中有系统预定义常量</p><pre><code>__FILE__ : php程序文件名__LINE__ : php程序行数PHP_VERSION : php版本PHP_OS : 执行解析php的操作系统TRUE or FALSE or NULL : 布尔值和空值E_ERROR : 指到最近错误处E_WARNING : 指到最近警告处E_PARSE : 指到解析语法有潜在问题处E_NOTICE : 不寻常处提示</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-PHP变量"><a href="#nbsp-nbsp-PHP变量" class="headerlink" title="&nbsp;&nbsp;PHP变量"></a>&nbsp;&nbsp;PHP变量</h3><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-变量声明及使用"><a href="#nbsp-nbsp-nbsp-nbsp-变量声明及使用" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;变量声明及使用"></a>&nbsp;&nbsp;&nbsp;&nbsp;变量声明及使用</h4><p>&nbsp;&nbsp;变量名称由 <strong>$</strong> 和 <strong>标识符</strong> 组成。标识符由字母、数字或下划线组成，且不能以数字开头。</p><p>&nbsp;&nbsp;变量赋值一般有直接赋值，还有变量间赋值。</p><pre><code>直接赋值和其他语言一样引用赋值在变量前加上 &amp; 符号取其他变量的地址区别：直接赋值是开辟新的内存空间，引用赋值则是多一个名字</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-变量作用域"><a href="#nbsp-nbsp-nbsp-nbsp-变量作用域" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;变量作用域"></a>&nbsp;&nbsp;&nbsp;&nbsp;变量作用域</h4><p>&nbsp;&nbsp;php和其他语言一样有局部变量，全局变量(<strong>global</strong>)和静态变量(<strong>static</strong>)</p><pre><code>全局变量：被定义在所有函数之外静态变量：能够在函数调用结束后仍然保留变量值，再次回到作用域时，可继续使用</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-可变变量"><a href="#nbsp-nbsp-nbsp-nbsp-可变变量" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;可变变量"></a>&nbsp;&nbsp;&nbsp;&nbsp;可变变量</h4><p>&nbsp;&nbsp;允许动态改变变量名称（套娃变量）</p><pre><code>$animal = &apos;turtles&apos;;      $turtles = 103;echo $$animal;则会输出103数字</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-PHP预定义变量"><a href="#nbsp-nbsp-nbsp-nbsp-PHP预定义变量" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;PHP预定义变量"></a>&nbsp;&nbsp;&nbsp;&nbsp;PHP预定义变量</h4><pre><code>$_GET — HTTP GET 变量$_POST — HTTP POST 变量$_FILES — HTTP 文件上传变量$_REQUEST — HTTP Request 变量$_SESSION — Session 变量$_COOKIE — HTTP Cookies，多数由setcookie()函数设置$_SERVER[&apos;REMOTE_ADDR&apos;] —— 浏览当前页面的用户的 IP 地址$_SERVER[&apos;SERVER_ADDR&apos;] —— 当前运行脚本所在的服务器的 IP 地址。$_SERVER[&apos;SERVER_NAME&apos;] —— 当前运行脚本所在的服务器的主机名$_SERVER[&apos;SERVER_PORT&apos;] —— 服务器使用的端口$_SERVER[&apos;DOCUMENT_ROOT&apos;] —— 当前运行脚本所在的文档根目录。在服务器配置文件中定义。$_SERVER[&apos;PHP_SELF&apos;] —— 获取当前网页地址（不含域名部分）$_SERVER[&apos;QUERY_STRING&apos;] —— 获取当前网页地址中的所有get数据（就是？号后面的部分），但只是一个整体的字符串而已$_SERVER[&apos;SCRIPT_FILENAME&apos;] —— 当前执行脚本的绝对路径$_SERVER[&apos;SERVER_SIGNATURE&apos;] —— 包含服务器版本和虚拟主机名的字符串</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-PHP运算符"><a href="#nbsp-nbsp-PHP运算符" class="headerlink" title="&nbsp;&nbsp;PHP运算符"></a>&nbsp;&nbsp;PHP运算符</h3><h4 id="nbsp-nbsp-nbsp-nbsp-算术运算符"><a href="#nbsp-nbsp-nbsp-nbsp-算术运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;算术运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;算术运算符</h4><p>&nbsp;&nbsp;主要有 <strong>+</strong>   <strong>-</strong> * <strong>/</strong> <strong>%</strong><br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-字符串运算符"><a href="#nbsp-nbsp-nbsp-nbsp-字符串运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;字符串运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;字符串运算符</h4><p>&nbsp;&nbsp;只有一个为英文的 <strong>.</strong> 将两个字符串连接起来。<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-赋值运算符"><a href="#nbsp-nbsp-nbsp-nbsp-赋值运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;赋值运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;赋值运算符</h4><p>&nbsp;&nbsp;基本运算符 <strong>=</strong> 将右边的值赋给左边的变量，可配合算数运算符<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-递增-递减运算符"><a href="#nbsp-nbsp-nbsp-nbsp-递增-递减运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;递增/递减运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;递增/递减运算符</h4><p>&nbsp;&nbsp;运算符 <strong>++</strong> 和 <strong>–</strong> 效果和其他语言相似<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-位运算符"><a href="#nbsp-nbsp-nbsp-nbsp-位运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;位运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;位运算符</h4><p>&nbsp;&nbsp;二进制位从低到高的运算</p><pre><code>&amp;    按位与|    按位或^    按位异或~    按位取反&lt;&lt;  向左移位&gt;&gt;  向右移位</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-逻辑运算符"><a href="#nbsp-nbsp-nbsp-nbsp-逻辑运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;逻辑运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;逻辑运算符</h4><p>&nbsp;&nbsp;用来组合逻辑运算的结果</p><pre><code>&amp;&amp; 或 and    逻辑与|| 或 or        逻辑或xor            逻辑异或！            逻辑非</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-比较运算符"><a href="#nbsp-nbsp-nbsp-nbsp-比较运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;比较运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;比较运算符</h4><p>&nbsp;&nbsp;对变量或表达式的结果进行大小真假的比较，真则true，假则false</p><pre><code>不常见的主要是 === 和 ！== ，这两个符号不仅判断数值，还判断数值的数据类型</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-条件运算符"><a href="#nbsp-nbsp-nbsp-nbsp-条件运算符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;条件运算符"></a>&nbsp;&nbsp;&nbsp;&nbsp;条件运算符</h4><p>&nbsp;&nbsp;<strong>(?:)</strong> 也称三目运算符，<strong>?</strong> 为前为判断表达式，真则进入 <strong>:</strong> 前的表达式，假则进入 <strong>：</strong> 后的<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-运算符优先级"><a href="#nbsp-nbsp-nbsp-nbsp-运算符优先级" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;运算符优先级"></a>&nbsp;&nbsp;&nbsp;&nbsp;运算符优先级</h4><p>&nbsp;&nbsp;查表即可<br>&nbsp;</p><h3 id="nbsp-nbsp-PHP函数"><a href="#nbsp-nbsp-PHP函数" class="headerlink" title="&nbsp;&nbsp;PHP函数"></a>&nbsp;&nbsp;PHP函数</h3><h4 id="nbsp-nbsp-nbsp-nbsp-定义和调用函数"><a href="#nbsp-nbsp-nbsp-nbsp-定义和调用函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;定义和调用函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;定义和调用函数</h4><p>&nbsp;&nbsp;函数，即将重复调用的功能卸载独立一个模块内</p><pre><code>创建函数基本语法格式：function fun_name($str1,...$strn){    fun_body}function    为声明自定义函数时必须使用的关键字fun_name    为自定义函数名$strn        为函数参数</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-函数间传递参数"><a href="#nbsp-nbsp-nbsp-nbsp-函数间传递参数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;函数间传递参数"></a>&nbsp;&nbsp;&nbsp;&nbsp;函数间传递参数</h4><p>&nbsp;&nbsp;1. <strong>按值传递</strong>：    传参在函数定义域内值改变不影响外部</p><p>&nbsp;&nbsp;2. <strong>按引用传递</strong>：     传参时加上 <strong>&amp;</strong> 将参数内存地址传入，函数定义域内外参数的值都会改变</p><p>&nbsp;&nbsp;3. <strong>默认参数</strong> ：    一般放在参数列表末尾，并指定默认值<br>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-函数返回值"><a href="#nbsp-nbsp-nbsp-nbsp-函数返回值" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;函数返回值"></a>&nbsp;&nbsp;&nbsp;&nbsp;函数返回值</h4><p>&nbsp;&nbsp;用 <strong>return</strong> 返回一个值，只能一个值，若要多个则需要创建数组</p><h4 id="nbsp-nbsp-nbsp-nbsp-变量函数"><a href="#nbsp-nbsp-nbsp-nbsp-变量函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;变量函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;变量函数</h4><p>&nbsp;&nbsp;基本效果如同可变变量一样（套娃）<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="nbsp-nbsp-条件控制语句"><a href="#nbsp-nbsp-条件控制语句" class="headerlink" title="&nbsp;&nbsp;条件控制语句"></a>&nbsp;&nbsp;条件控制语句</h3><p>&nbsp;&nbsp;包括 <strong>if</strong> , <strong>if else</strong> , <strong>elseif</strong> , <strong>switch</strong> </p><h3 id="nbsp-nbsp-循环控制语句"><a href="#nbsp-nbsp-循环控制语句" class="headerlink" title="&nbsp;&nbsp;循环控制语句"></a>&nbsp;&nbsp;循环控制语句</h3><p>&nbsp;&nbsp;包括 <strong>while</strong> ， <strong>do…while</strong> , <strong>for</strong> ，<strong>foreach</strong></p><p>&nbsp;&nbsp;<strong>foreach</strong> 语句将遍历数组内</p><pre><code>foreach($array as $value)    语句;或foreach($array as $key =&gt;$value)    语句;</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-跳转语句"><a href="#nbsp-nbsp-跳转语句" class="headerlink" title="&nbsp;&nbsp;跳转语句"></a>&nbsp;&nbsp;跳转语句</h3><p>&nbsp;&nbsp;包括了 <strong>break</strong> ， <strong>continue</strong></p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="nbsp-nbsp-字符串定义"><a href="#nbsp-nbsp-字符串定义" class="headerlink" title="&nbsp;&nbsp;字符串定义"></a>&nbsp;&nbsp;字符串定义</h3><h4 id="nbsp-nbsp-nbsp-nbsp-引号定义"><a href="#nbsp-nbsp-nbsp-nbsp-引号定义" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;引号定义"></a>&nbsp;&nbsp;&nbsp;&nbsp;引号定义</h4><p>&nbsp;&nbsp;单引号的内容只会将内容原样输出，而双引号会对内的变量进行替换然后输出</p><h4 id="nbsp-nbsp-nbsp-nbsp-定界符定义"><a href="#nbsp-nbsp-nbsp-nbsp-定界符定义" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;定界符定义"></a>&nbsp;&nbsp;&nbsp;&nbsp;定界符定义</h4><p>&nbsp;&nbsp;定界符 <strong>&lt;&lt;&lt;</strong> 用于定义格式化的大文本，定界符内的字符串支持单双引号，并且支持字符变量替换</p><pre><code>&lt;&lt;&lt;（用户自定符号）    文本内容（用户自定符号）</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-字符串操作"><a href="#nbsp-nbsp-字符串操作" class="headerlink" title="&nbsp;&nbsp;字符串操作"></a>&nbsp;&nbsp;字符串操作</h3><h4 id="nbsp-nbsp-nbsp-nbsp-去除字符串特殊字符和首尾空格"><a href="#nbsp-nbsp-nbsp-nbsp-去除字符串特殊字符和首尾空格" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;去除字符串特殊字符和首尾空格"></a>&nbsp;&nbsp;&nbsp;&nbsp;去除字符串特殊字符和首尾空格</h4><p>&nbsp;&nbsp;对用户输入字符进行过滤空格和特殊字符，有 <strong>trim()</strong> , <strong>ltrim()</strong> ，<strong>rtrim()</strong> 来去除</p><p>&nbsp;&nbsp;1.<strong>trim()</strong> 函数</p><pre><code>string trim(string str [,string charlist]);trim()主要用于过滤字符串首尾字符str 是要操作的字符串对象；charlist为可选参数，一般列出所有希望过滤的字符</code></pre><p>&nbsp;<br>&nbsp;&nbsp;2.<strong>ltrim()</strong> 函数</p><pre><code>string ltrim(string str [,string charlist]);ltrim()主要用于过滤字符串左边字符，参数和trim()一样</code></pre><p>&nbsp;<br>&nbsp;&nbsp;3.<strong>rtrim()</strong> 函数</p><pre><code>string ltrim(string str [,string charlist]);rtrim()主要用于过滤字符串右边字符，参数和trim()一样</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-转义和还原字符串数据"><a href="#nbsp-nbsp-nbsp-nbsp-转义和还原字符串数据" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;转义和还原字符串数据"></a>&nbsp;&nbsp;&nbsp;&nbsp;转义和还原字符串数据</h4><p>&nbsp;&nbsp;一共有两种转义、还原字符串方式：<strong>手工和自动</strong></p><p>&nbsp;&nbsp;1.手动</p><p>&nbsp;&nbsp;使用 <strong>\</strong> 将后面第一个字符变得没有特殊意义</p><p>&nbsp;&nbsp;2.自动</p><p>&nbsp;&nbsp;①<strong>addslashes()</strong>函数</p><pre><code>string addslashes(string str)addlashes函数是使用反斜线引用字符串str为要转义的字符串，返回值为转义后的字符</code></pre><p>&nbsp;<br>&nbsp;&nbsp;②<strong>stripslashes()</strong>函数</p><pre><code>string stripslashes(string str)stripslashes函数是反引用一个引用字符串，即将addslashes函数转义后的字符串还原str为要还原的字符串</code></pre><p>&nbsp;<br>&nbsp;&nbsp;③<strong>addcslashes()</strong>函数</p><pre><code>string addcslashes(string str,string charlist)addcslashes函数对指定的字符串前加上反斜线str为将要被操作的字符串，charlist则指定字符串中哪些字符串加反斜线</code></pre><p>&nbsp;<br>&nbsp;&nbsp;④<strong>stripcslashes()</strong>函数</p><pre><code>string stripcslashes(string str)stripcslashes函数对addcslashes函数转义的字符进行还原str为要还原的字符串</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-获取字符串长度"><a href="#nbsp-nbsp-nbsp-nbsp-获取字符串长度" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;获取字符串长度"></a>&nbsp;&nbsp;&nbsp;&nbsp;获取字符串长度</h4><p>&nbsp;&nbsp;主要使用 <strong>strlen()</strong> 函数进行获取</p><pre><code>int strlen(string str)获取字符串长度</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-截取字符串"><a href="#nbsp-nbsp-nbsp-nbsp-截取字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;截取字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;截取字符串</h4><p>&nbsp;&nbsp;对字符串截取可以采用预定义函数 <strong>substr()</strong> 函数实现</p><pre><code>string substr(string str,int start[,int length])str     指定字符串对象start    指定开始截取字符串的位置，若为负数则从字符串末尾开始length    可选参数，指定截取字符串个数，若为负数则表示取倒数第length个字符</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-比较字符串"><a href="#nbsp-nbsp-nbsp-nbsp-比较字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;比较字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;比较字符串</h4><p>&nbsp;&nbsp;比较方法主要有三种：<strong>按照字节，按照自然排序和指定源字符串位置开始</strong></p><p>&nbsp;&nbsp;①按照字节进行字符串比较：<strong>strcmp()</strong> 和 <strong>strcasecmp()</strong></p><pre><code>int strcmp(string str1 , string str2)int strcasecmp(string str1 , string str2)str1和str2为比较的字符串，相等则返回0，str1大于str2返回值大于0，小于则返回小于0strcmp()和strcasecmp()差别在于：strcmp()区分大小写而strcasecmp()不区分</code></pre><p>&nbsp;<br>&nbsp;&nbsp;②按自然排序法进行比较：<strong>strnatcmp()</strong></p><pre><code>int strnatcmp(string str1 , string str2)strnatcmp()将字符串中的字符从左到右顺序进行比较数字和数字比较按照自然排序法，其他则按照ACSII码值比较str1和str2为比较的字符，相等返回0，str1比str2大则返回大于0，小则返回小于0</code></pre><p>&nbsp;<br>&nbsp;&nbsp;③指定从源字符串位置开始比较：<strong>strncmp()</strong></p><pre><code>int strncmp(string str1 , string str2 , int len)len为必要参数，指定每个字符串中参与比较的字符串数量strncmp 区分函数大小写返回值和上面的相同</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-检索字符串"><a href="#nbsp-nbsp-nbsp-nbsp-检索字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;检索字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;检索字符串</h4><p>&nbsp;&nbsp;① <strong>strstr()</strong> 函数</p><p>&nbsp;&nbsp;用于获取一个指定字符串在另一个字符串中首次出现的位置到后者末尾的子字符串，成功则返回剩余字符串，失败则返回false。简单的说就是返回一个字符串某个标识后面所有字符。</p><pre><code>string strstr(string haystack ， string needle)haystack    必要参数，指定从哪个字符串中进行检索needle        必要参数，指定搜索对象。strstr()区分字母大小写//大小写绕过</code></pre><p>&nbsp;<br>&nbsp;&nbsp;② <strong>substr_count()</strong> 函数</p><p>&nbsp;&nbsp;获取指定字符在字符串中出现的次数</p><pre><code>int substr_count(string haystack ， string needle)haystack    指定字符串needle        指定字符</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-替换字符串"><a href="#nbsp-nbsp-nbsp-nbsp-替换字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;替换字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;替换字符串</h4><p>&nbsp;&nbsp;① <strong>str_ireplace()</strong> 函数</p><p>&nbsp;&nbsp;使用新的字符串替换原始字符串中指定的字符</p><pre><code>mixed str_ireplace(mixed search ，mixed replace，mixed subject [，int &amp;count])search    必要参数，要搜索的值，可以用array来提供多个值replace    必要参数，指定替换的值subject    必要参数，要被搜索和替换的字符串或数组count    可选参数，执行替换的数量str_ireplace 函数不区分大小写</code></pre><p>&nbsp;<br>&nbsp;&nbsp;② <strong>substr_replace()</strong> 函数</p><p>&nbsp;&nbsp;用于对指定字符串中的部分字符串进行替换</p><pre><code>mixed substr_replace(mixed string，mixed repl，mixed start ，[mixed length])string    指定要操作的原始字符串repl    指定要替换后的新字符串start    指定替换字符串开始的位置length    可选参数，指定返回的字符串长度，默认是返回整个字符串若start为负数，而length小于或等于start的值，length的值为0</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-格式化字符串"><a href="#nbsp-nbsp-nbsp-nbsp-格式化字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp; 格式化字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp; 格式化字符串</h4><p>&nbsp;&nbsp;<strong>number_format()</strong> 函数可用来将数字字符串格式化</p><pre><code>string number_format(float number[,int decimals[,string dec_point[,string thousands_sep]]])number            为要格式化的数字decimals        为要保留的小数位数dec_point        为指定小数点显示的字符thousands_sep    为指定千位分隔符显示的字符</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-分割和合成字符串"><a href="#nbsp-nbsp-nbsp-nbsp-分割和合成字符串" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;分割和合成字符串"></a>&nbsp;&nbsp;&nbsp;&nbsp;分割和合成字符串</h4><p>&nbsp;&nbsp;① <strong>explode()</strong> 函数按照一定规则对一个字符串进行分割</p><pre><code>array explode(string delimiter,string str[,int limit])delimiter    边界上的分隔符str            必要参数，指定将要被分割的字符串limit        可选参数，若设置了limit参数，则返回的数组包含最多limit个字符注意：返回是以数组形式</code></pre><p>&nbsp;<br>&nbsp;&nbsp;② <strong>implode()</strong> 函数将数组内的内容合成一个新的字符串</p><pre><code>string implode(string glue,array pieces)glue    字符串类型pieces    数组类型，指定要被合并的数组</code></pre><p>&nbsp;</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="nbsp-nbsp-正则表达式的概念"><a href="#nbsp-nbsp-正则表达式的概念" class="headerlink" title="&nbsp;&nbsp;正则表达式的概念"></a>&nbsp;&nbsp;正则表达式的概念</h3><p>&nbsp;&nbsp;正则表达式是一种描述字符串结构的语法规则，是一种特定的格式化模式，可以<strong>匹配、替换、截取匹配的字符串</strong>，类似dos命令中的    dir *.txt</p><p>&nbsp;&nbsp;这里说明几种术语</p><pre><code>grep    最初是ED编辑器的一条命令，用于显示文件中的特定内容，后独立成一个工具egrep    grep的扩展版，大大增强grep的能力POSIX    可移植操作系统接口，POSIX是一系列标准，确保操作系统之间的可移植性Perl    实际抽取与汇报语言，成为与POSIX之后的另一个标准PCRE    兼容Perl正则表达式的一套正则引擎，PHP正是使用该引擎之一</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-正则表达式的语法规则"><a href="#nbsp-nbsp-正则表达式的语法规则" class="headerlink" title="&nbsp;&nbsp;正则表达式的语法规则"></a>&nbsp;&nbsp;正则表达式的语法规则</h3><p>&nbsp;&nbsp;一个完整的正则表达式由两部分构成，<strong>元字符</strong>和<strong>文本字符</strong>。元字符是具有特殊含义的字符，如前面列举dos命令中的 * 符号。文本字符就是普通文本，如数字和字母。PCRE风格的正则表达式一般都是放置在定界符 <strong>/</strong> 中间。</p><h4 id="nbsp-nbsp-nbsp-nbsp-行定位符-和"><a href="#nbsp-nbsp-nbsp-nbsp-行定位符-和" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;行定位符(^ 和 $)"></a>&nbsp;&nbsp;&nbsp;&nbsp;行定位符(<strong>^</strong> 和 <strong>$</strong>)</h4><p>&nbsp;&nbsp;行定位符就是用来描述字符的边界。__ <strong>^</strong> 表示行的开始， <strong>$</strong> 表示行的结尾。__</p><pre><code>^tm 该表达式表示要匹配字串 tm 的开始位置是行头例如： tm this is a dog 就可以匹配，this is a dog tm 则不匹配tm$ 则可以匹配例子:this is a dog tmtm 则匹配的字串可以出现在字符串任意位置</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-单词分界符-b-和-B"><a href="#nbsp-nbsp-nbsp-nbsp-单词分界符-b-和-B" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;单词分界符(\b  和 \B)"></a>&nbsp;&nbsp;&nbsp;&nbsp;单词分界符(<strong>\b</strong>  和 <strong>\B</strong>)</h4><p>&nbsp;&nbsp;以上面的例子，若按照 tm 则会匹配出 html 内的一部分 tm 而非一个单词 tm ，这是则可使用单词分界符 <strong>\b</strong> 表示，<strong>这表示要查找的是为一个完整的单词</strong>。 </p><pre><code>\btm\b</code></pre><p>&nbsp;&nbsp;<strong>\B</strong> 正好相反，<strong>表示匹配的是单词或字符串的一部分</strong>。</p><pre><code>\Btm\B</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-字符类"><a href="#nbsp-nbsp-nbsp-nbsp-字符类" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;字符类([ ])"></a>&nbsp;&nbsp;&nbsp;&nbsp;字符类([ ])</h4><p>&nbsp;&nbsp;正则表达式是区分大小写的，若要<strong>忽略大小写</strong>则使用 <strong>[ ]</strong></p><pre><code>若要匹配 tm 不区分大小写则应该写作：[Tt][Mm]</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-选择字符"><a href="#nbsp-nbsp-nbsp-nbsp-选择字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;选择字符( | )"></a>&nbsp;&nbsp;&nbsp;&nbsp;选择字符( | )</h4><p>&nbsp;&nbsp;若要忽略大小写还可以使用选择字符，符号理解成<strong>或</strong></p><pre><code>匹配 tm 不区分大小写也可以写成：(T|t)(M|m)| 和 [] 符号的差别在于前者可以匹配任意长度的字符串，后者只能匹配单个字符</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-连字符"><a href="#nbsp-nbsp-nbsp-nbsp-连字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;连字符( - )"></a>&nbsp;&nbsp;&nbsp;&nbsp;连字符( - )</h4><p>&nbsp;&nbsp;<strong>匹配变量的第一个字母</strong>可以使用连字符解决</p><pre><code>[a-zA-Z]</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-排除字符"><a href="#nbsp-nbsp-nbsp-nbsp-排除字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;排除字符([^])"></a>&nbsp;&nbsp;&nbsp;&nbsp;排除字符([^])</h4><p>&nbsp;&nbsp;<strong>若要匹配不符合规则的变量</strong>，可以使用 ^ 符号</p><pre><code>匹配不以字母开头的变量：[^a-zA-Z]</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-限定符-n-m"><a href="#nbsp-nbsp-nbsp-nbsp-限定符-n-m" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;限定符( ?*+{n,m} )"></a>&nbsp;&nbsp;&nbsp;&nbsp;限定符( ?*+{n,m} )</h4><p>&nbsp;&nbsp;对于<strong>重复出现的字符串</strong>，可以使用限定符来实现匹配</p><pre><code>?        匹配前面的字符零次或一次+        匹配前面的字符一次或多次*        匹配前面的字符零次或多次{n,}    匹配前面的字符n次{,m}    匹配前面的字符最少n次{n,m}    匹配前面的字符最少n次 最多m次</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-点号字符"><a href="#nbsp-nbsp-nbsp-nbsp-点号字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;点号字符( . )"></a>&nbsp;&nbsp;&nbsp;&nbsp;点号字符( . )</h4><p>&nbsp;&nbsp;点号可以<strong>匹配出换行符外的任意一个字符</strong></p><pre><code>匹配s开头、t结尾、中间一个任意字母的单词：    ^s.t$匹配第一个字母为r、第三个为s、最后一个为t：    ^r.s.*t$</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-转义字符"><a href="#nbsp-nbsp-nbsp-nbsp-转义字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;转义字符( \ )"></a>&nbsp;&nbsp;&nbsp;&nbsp;转义字符( \ )</h4><p>&nbsp;&nbsp;和普通用法里面差不多，都是将<strong>特殊字符转义为普通字符</strong></p><pre><code>匹配IP地址：[0-9]{1,3}(.[0-9]{1,3}){3}</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-反斜线"><a href="#nbsp-nbsp-nbsp-nbsp-反斜线" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;反斜线()"></a>&nbsp;&nbsp;&nbsp;&nbsp;反斜线()</h4><p>&nbsp;&nbsp;反斜线除了做转义字符以外，还可以<strong>显示不可打印字符，指定预定义字符集、定义断言</strong></p><pre><code>显示不可打印字符：    \a        警报指定预定义字符集：    \d        任意一个十进制数字定义断言;            例如前面介绍的\b \B</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-括号字符"><a href="#nbsp-nbsp-nbsp-nbsp-括号字符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;括号字符()"></a>&nbsp;&nbsp;&nbsp;&nbsp;括号字符()</h4><p>&nbsp;&nbsp;括号第一个作用就是<strong>改变限定符的作用范围</strong></p><p>&nbsp;&nbsp;第二个作用就是分组</p><pre><code>分组：例如前面匹配IP地址，括号加上表示对分组进行重复操作</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-反向作用"><a href="#nbsp-nbsp-nbsp-nbsp-反向作用" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;反向作用"></a>&nbsp;&nbsp;&nbsp;&nbsp;反向作用</h4><p>&nbsp;&nbsp;反向引用就是依靠子表达式的记忆功能来匹配连续出现的字符串或字母</p><h4 id="nbsp-nbsp-nbsp-nbsp-模式修饰符"><a href="#nbsp-nbsp-nbsp-nbsp-模式修饰符" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;模式修饰符"></a>&nbsp;&nbsp;&nbsp;&nbsp;模式修饰符</h4><p>&nbsp;&nbsp;模式修饰符的作用就是设定模式，规定正则表达式应该如何解释和应用</p><pre><code>i    忽略大小写模式    写法 (?i)...(?-i) or (?i:...)m    多文本模式        写法 如上，换个字母即可s    单文本模式        写法 如上x    忽略空白字符        写法 如上</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-PCRE兼容正则表达式函数"><a href="#nbsp-nbsp-PCRE兼容正则表达式函数" class="headerlink" title="&nbsp;&nbsp;PCRE兼容正则表达式函数"></a>&nbsp;&nbsp;PCRE兼容正则表达式函数</h3><h4 id="nbsp-nbsp-nbsp-nbsp-preg-grep-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-grep-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_grep()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_grep()函数</h4><p>&nbsp;&nbsp;该函数使用数组input中的元素一一匹配表达式pattern，最后返回由所有相匹配的元素所组成的数组。</p><pre><code>array preg_grep( string pattern,array input )</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-preg-match-和preg-match-all-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-match-和preg-match-all-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_match()和preg_match_all()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_match()和preg_match_all()函数</h4><p>&nbsp;&nbsp;在字符串subject中匹配表达式pattern，函数返回匹配的次数。如果有数组matches，那每次匹配的结果都会存储到数组matches中。</p><pre><code>int preg_match/preg_match_all(string pattern,string subject[,array matches])</code></pre><p>&nbsp;<br>&nbsp;&nbsp;对于<strong>preg_match()函数的返回值只会是0和1</strong>，因为该函数在<strong>匹配成功一次后便停止继续查找</strong>。而<strong>preg_match_all()则会匹配到最后才会停止</strong>。故对于preg_match()来说,matches数组可有可无，但对preg_match_all()函数来说则必须有。</p><h4 id="nbsp-nbsp-nbsp-nbsp-preg-quote-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-quote-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_quote()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_quote()函数</h4><p>&nbsp;&nbsp;函数将字符串str中的所有特殊字符串进行自动转义，如果有参数delimiter，那么该参数所包含的字符串也将被转义。</p><pre><code>string preg_quote(string str[,string delimiter])</code></pre><p>&nbsp;</p><h4 id="nbsp-nbsp-nbsp-nbsp-preg-replace-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-replace-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_replace()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_replace()函数</h4><p>&nbsp;&nbsp;函数在字符串subject中匹配表达式pattern，并将匹配项替换成字符串replacement，如果有参数limit，则替换limit次。</p><pre><code>mixed preg_replace(mixed pattern,mixed replacement,mixed subject[,int limit])</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-preg-replace-callback-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-replace-callback-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_replace_callback()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_replace_callback()函数</h4><p>&nbsp;&nbsp;与preg_replace()函数功能相同，都用于查找和替换字串。不同的是，preg_replace_callback()函数使用一个回调函数来代替replacement参数。</p><pre><code>mixed preg_callback(mixed pattern,callback callback,mixed subject[,int limit])</code></pre><h4 id="nbsp-nbsp-nbsp-nbsp-preg-split-函数"><a href="#nbsp-nbsp-nbsp-nbsp-preg-split-函数" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;preg_split()函数"></a>&nbsp;&nbsp;&nbsp;&nbsp;preg_split()函数</h4><p>&nbsp;&nbsp;使用表达式pattern来分割subject。如果有参数limit，数组最多有limit个元素。</p><pre><code>array preg_split(string pattern,string subject[,int limit])</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="nbsp-nbsp-声明数组"><a href="#nbsp-nbsp-声明数组" class="headerlink" title="&nbsp;&nbsp;声明数组"></a>&nbsp;&nbsp;声明数组</h3><p>&nbsp;&nbsp;主要有两种声明方式，一种是array()函数，另一种是通过为数组元素赋值的方式声明数组。</p><pre><code>array array([mixed,...])mixed 的语法为key =&gt; value,多个参数mixed间用逗号隔开，分别定义了索引和值定义数组：    $array = array(&quot;asp&quot;,&quot;php&quot;,&quot;jsp&quot;)；或：    $array = array(&quot;1&quot;=&gt;&quot;asp&quot;,&quot;2&quot;=&gt;&quot;php&quot;);还可以:    $array[1]=&quot;asp&quot;;    $array[2]=&quot;php&quot;;输出下标元素:    echo $array[1];（单个）或    print_r($array)；（所有）</code></pre><p>&nbsp;</p><h3 id="nbsp-nbsp-数组的类型"><a href="#nbsp-nbsp-数组的类型" class="headerlink" title="&nbsp;&nbsp;数组的类型"></a>&nbsp;&nbsp;数组的类型</h3><p>&nbsp;&nbsp;PHP支持两种数组，索引数组（indexed array）和联合数组（associative array）。</p><h4 id="nbsp-nbsp-nbsp-nbsp-数字索引数组"><a href="#nbsp-nbsp-nbsp-nbsp-数字索引数组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;数字索引数组"></a>&nbsp;&nbsp;&nbsp;&nbsp;数字索引数组</h4><p>&nbsp;&nbsp;数字索引一般表示数组元素在数组中的位置，由数字组成，下标从0开始</p><h4 id="nbsp-nbsp-nbsp-nbsp-关联数组"><a href="#nbsp-nbsp-nbsp-nbsp-关联数组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;关联数组"></a>&nbsp;&nbsp;&nbsp;&nbsp;关联数组</h4><p>&nbsp;&nbsp;关联数组的键名可以是数值和字符串混合的形式，只要有一个键名不是数字，那么就是关联数组。（就是将diy键名）</p><h3 id="nbsp-nbsp-输出数组"><a href="#nbsp-nbsp-输出数组" class="headerlink" title="&nbsp;&nbsp;输出数组"></a>&nbsp;&nbsp;输出数组</h3><p>&nbsp;&nbsp;输出数组可以使用echo、print语句，但是只能对数组的某元素进行输出，print_r()则可以输出数组结构。</p><pre><code>bool print_r(mixed expression)</code></pre><h3 id="nbsp-nbsp-数组构造"><a href="#nbsp-nbsp-数组构造" class="headerlink" title="&nbsp;&nbsp;数组构造"></a>&nbsp;&nbsp;数组构造</h3><h4 id="nbsp-nbsp-nbsp-nbsp-一维数组"><a href="#nbsp-nbsp-nbsp-nbsp-一维数组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;一维数组"></a>&nbsp;&nbsp;&nbsp;&nbsp;一维数组</h4><p>&nbsp;&nbsp;当一个数组的元素是变量时，称为一维数组。</p><h4 id="nbsp-nbsp-nbsp-nbsp-二维数组"><a href="#nbsp-nbsp-nbsp-nbsp-二维数组" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;二维数组"></a>&nbsp;&nbsp;&nbsp;&nbsp;二维数组</h4><p>&nbsp;&nbsp;当一个数组的元素一维数组（套娃），则称为二维数组。</p><h3 id="nbsp-nbsp-遍历数组"><a href="#nbsp-nbsp-遍历数组" class="headerlink" title="&nbsp;&nbsp;遍历数组"></a>&nbsp;&nbsp;遍历数组</h3><h4 id="nbsp-nbsp-nbsp-nbsp-foreach结构遍历"><a href="#nbsp-nbsp-nbsp-nbsp-foreach结构遍历" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;foreach结构遍历"></a>&nbsp;&nbsp;&nbsp;&nbsp;foreach结构遍历</h4><p>&nbsp;&nbsp;如上</p><h4 id="nbsp-nbsp-nbsp-nbsp-list-函数遍历"><a href="#nbsp-nbsp-nbsp-nbsp-list-函数遍历" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;list()函数遍历"></a>&nbsp;&nbsp;&nbsp;&nbsp;list()函数遍历</h4><p>&nbsp;&nbsp;把数组中的值赋给一些变量</p><pre><code>void list(mixed ...)</code></pre>]]></content>
    
    
    <categories>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/07/30/hello-world/"/>
    <url>/2020/07/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>&nbsp; </p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
